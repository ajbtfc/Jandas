{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jandas: Pandas-Like DataFrames in Ignition","text":"<p>Welcome to Jandas, a lightweight Python library designed to bring familiar <code>pandas</code>-style data manipulation to the Ignition platform.</p> <p>Jandas provides a simple, intuitive interface for working with tabular data in environments where the full power of <code>pandas</code> isn\u2019t available \u2014 such as Jython scripting in Ignition. If you've ever wished for <code>.groupby()</code>, <code>.rolling()</code>, or <code>.loc[]</code> support while working inside your Ignition gateway or Perspective scripts, Jandas aims to give you just that.</p>"},{"location":"#what-jandas-is","title":"What Jandas Is","text":"<ul> <li>A minimal re-implementation of core <code>pandas</code> features, tailored for environments like Ignition where the real <code>pandas</code> cannot run.</li> <li>Designed to work with Python objects like lists and dictionaries, common in Ignition datasets.</li> <li>Offers a familiar interface with classes like <code>DataFrame</code>, <code>Series</code>, and <code>GroupBy</code>.</li> </ul>"},{"location":"#limitations","title":"Limitations","text":"<ul> <li>Jandas is written in pure Python, not C or NumPy \u2014 which means it does not match the performance of <code>pandas</code>, especially for large datasets.</li> <li>It is focused on developer convenience and readability, not computational efficiency.</li> <li>Some advanced features of <code>pandas</code> (e.g. time series indexing, multi-indexing, broadcasting, custom dtypes) are not fully implemented.</li> <li>This project is still under active development \u2014 interfaces, behavior, and performance may change over time.</li> </ul>"},{"location":"#when-to-use-jandas","title":"When to Use Jandas","text":"<ul> <li>You're working inside Ignition or another Jython environment without access to <code>pandas</code>.</li> <li>You want to write clear, expressive, and testable data logic that resembles modern Python data workflows.</li> <li>You\u2019re operating on moderate-sized datasets where performance isn\u2019t the top concern.</li> </ul>"},{"location":"#when-not-to-use-jandas","title":"When Not to Use Jandas","text":"<ul> <li>You need high-performance data manipulation (use native <code>pandas</code> in a proper Python runtime instead).</li> <li>Your dataset contains millions of rows and complex statistical transformations.</li> <li>You require third-party integration with the broader Python data science ecosystem.</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Jandas is alpha-stage software. While the core functionality is usable, the API may change, and performance optimizations are ongoing.</p> <p>You are welcome to use it, experiment with it, and contribute ideas or code \u2014 but be prepared for occasional sharp edges!</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>DataFrame</li> <li>JIndex</li> <li>GroupBy</li> <li>Rolling</li> </ul> <p>For Ignition users and curious developers alike, we hope Jandas helps bridge the gap between industrial scripting and modern data analysis.</p>"},{"location":"dataframe_dataframe/","title":"API Reference","text":""},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame","title":"<code>Jandas.dataframe.DataFrame</code>","text":"<p>A simplified representation of a tabular data structure, similar to a spreadsheet or SQL table.</p> <p>This class stores data in rows, each encapsulated in a Vector, and maintains an ordered set of column names. It optionally supports a custom row index.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame--attributes","title":"Attributes:","text":"<p>data : List[Vector]     The rows of the DataFrame, where each row is stored as a Vector with named fields.</p> JIndex <p>The column labels for the DataFrame. Used for aligning and accessing column values.</p> Optional[List[Any]] <p>An optional list representing custom row labels or indices.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame--initialization-notes","title":"Initialization Notes:","text":"<ul> <li>Data can be passed as a list of lists, a list of Vectors, or a dictionary mapping column names to lists.</li> <li>If data is not provided, an empty table is created with the specified columns and index.</li> <li>If data is a dictionary, each key is treated as a column and its associated values as column data.</li> <li>Columns are automatically padded with None if they have unequal lengths.</li> </ul>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame--raises","title":"Raises:","text":"<p>TypeError:     If the input data format is unsupported.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>class DataFrame:\n    \"\"\"\n    A simplified representation of a tabular data structure, similar to a spreadsheet or SQL table.\n\n    This class stores data in rows, each encapsulated in a Vector, and maintains an ordered set of column names.\n    It optionally supports a custom row index.\n\n    Attributes:\n    ----------\n    data : List[Vector]\n        The rows of the DataFrame, where each row is stored as a Vector with named fields.\n\n    columns : JIndex\n        The column labels for the DataFrame. Used for aligning and accessing column values.\n\n    Index : Optional[List[Any]]\n        An optional list representing custom row labels or indices.\n\n    Initialization Notes:\n    ---------------------\n    - Data can be passed as a list of lists, a list of Vectors, or a dictionary mapping column names to lists.\n    - If data is not provided, an empty table is created with the specified columns and index.\n    - If data is a dictionary, each key is treated as a column and its associated values as column data.\n    - Columns are automatically padded with None if they have unequal lengths.\n\n    Raises:\n    -------\n    TypeError:\n        If the input data format is unsupported.\n    \"\"\"\n\n    def __init__(self, data=None, columns=None, index=None):\n        \"\"\"\n        Initialize a DataFrame.\n\n        Parameters:\n        - data: 2D list or list of Vectors representing rows of data.\n        - columns: List of column names.\n        \"\"\"\n        self.Index = index\n\n        if columns is None:\n            columns = []\n        if data is None:\n            # Defer assigning data until we have both index and columns\n            self.columns = JIndex(columns)\n            numRows = len(index) if index is not None else 0\n            self.data = [Vector([None] * len(columns), columns) for _ in range(numRows)]\n            return\n        if isinstance(data, dict):\n            # Dict of columns: convert to list of rows\n            columns = list(data.keys()) if not columns else columns\n            colData = [data.get(col, []) for col in columns]\n            numRows = max(len(col) for col in colData)\n            # pad shorter columns with None\n            paddedCols = [col + [None] * (numRows - len(col)) for col in colData]\n            rows = zip(*paddedCols)\n            self.data = [Vector(list(row), columns) for row in rows]\n            self.columns = JIndex(columns)\n            return\n        elif isinstance(data, list):\n            if len(data) &gt; 0 and isinstance(data[0], Vector):\n                self.data = data\n            else:\n                self.data = [Vector(row, columns) for row in data]\n            self.columns = JIndex(columns)\n            return\n\n        else:\n            raise TypeError(\"Unsupported data type for DataFrame initialization.\")\n\n    @property\n    def index(self):\n        \"\"\"\n        Returns the index of the DataFrame.\n\n        If a custom index (Index) has been set, it is returned.\n        Otherwise, a default RangeIndex is returned based on the length of the data.\n        \"\"\"\n        return self.Index if self.Index is not None else range(len(self.data))\n\n    @index.setter\n    def index(self, newIndex):\n        \"\"\"\n        Set a new custom index for the DataFrame.\n\n        Parameters:\n        - newIndex: List of new index values. Must match the number of rows.\n        \"\"\"\n        if len(newIndex) != len(self.data):\n            raise ValueError(\"Length of new index must match number of rows in the DataFrame.\")\n        self.Index = newIndex\n\n    @property\n    def ndim(self):\n        \"\"\"\n        Get the number of dimensions of the DataFrame.\n\n        Returns:\n        - 2 (always for a DataFrame).\n        \"\"\"\n        return 2  # Since it's a DataFrame, it has 2 dimensions\n\n    @property\n    def size(self):\n        \"\"\"\n        Get the total number of elements in the DataFrame.\n\n        Returns:\n        - Integer representing the total number of elements.\n        \"\"\"\n        return len(self.data) * len(self.columns)\n\n    @property\n    def loc(self):\n        \"\"\"\n        Get a _LocIndexer for label-based indexing.\n\n        Returns:\n        - _LocIndexer object.\n        \"\"\"\n        return _LocIndexer(self, vectorCls=Vector, dataframeCls=DataFrame)\n\n    @property\n    def iloc(self):\n        \"\"\"\n        Get an _IlocIndexer for position-based indexing.\n\n        Returns:\n        - _IlocIndexer object.\n        \"\"\"\n\n        return _IlocIndexer(self)\n\n    @property\n    def axes(self):\n        \"\"\"\n        Get the axes of the DataFrame (index and columns).\n\n        Returns:\n        - Named tuple containing index and columns as Series objects.\n        \"\"\"\n        from collections import namedtuple\n        Axis = namedtuple('Axis', ['index', 'columns'])\n        index = Series(list(range(len(self.data))), name='index')\n        columns = Series(self.columns, name='columns')\n        return Axis(index=index, columns=columns)\n\n    @property\n    def values(self):\n        \"\"\"\n        Get the values of the DataFrame as a 2D list.\n\n        Returns:\n        - 2D list of values.\n        \"\"\"\n        # Return the 2D list of values (rows of vectors)\n        return [row.as_array() for row in self.data]\n\n    @property\n    def shape(self):\n        \"\"\"\n        Get the shape of the DataFrame.\n\n        Returns:\n        - Tuple (number of rows, number of columns).\n        \"\"\"\n        return len(self.data), len(self.columns)\n\n    @property\n    def dtypes(self):\n        \"\"\"\n        Get the data types of each column in the DataFrame.\n\n        Returns:\n        - List of data types for each column.\n        \"\"\"\n        types = []\n        for col in range(len(self.columns)):\n            columnData = [row[col] for row in self.data]\n            if all(isinstance(val, (int, float)) for val in columnData):\n                types.append('float' if any(isinstance(val, float) for val in columnData) else 'int')\n            else:\n                types.append('object')\n\n        # Create a Series to hold dtype info, with column names as the index\n        dtypeSeries = Series(types, name='dtype')\n        dtypeSeries.index = self.columns  # Set the column names as the index\n        return dtypeSeries\n\n    def rowByLabel(self, label):\n        # Handle single-element tuple indexing\n        if self.index and isinstance(self.index[0], tuple) and len(self.index[0]) == 1:\n            label = (label,)\n        idx = self.index.index(label)\n        return self.data[idx]\n\n    def set_index(self, columnName, inplace=False):\n        \"\"\"\n        Set a specified column as the index of the DataFrame.\n\n        Args:\n            columnName (str): Name of the column to set as the index.\n            inplace (bool): Whether to modify the DataFrame in place. If False, returns a new DataFrame.\n\n        Returns:\n            self: If inplace is False, returns a new DataFrame with the index set.\n\n        Raises:\n            ValueError: If the specified column name does not exist.\n        \"\"\"\n        if columnName not in self.columns:\n            raise ValueError(\"Column '{}' does not exist.\".format(columnName))\n        colIndex = self.columns.index(columnName)\n\n        # Extract the new index values\n        self.index = [row[colIndex] for row in self.data]\n\n        # Create new rows without the index column\n        self.data = [Vector([value for i, value in enumerate(row) if i != colIndex]) for row in self.data]\n\n        # Update the column names\n        self.columns = JIndex([col for i, col in enumerate(self.columns) if i != colIndex])\n        if inplace:\n            return\n        else:\n            return self\n\n    def reset_index(self, name=\"index\"):\n        \"\"\"\n        Move the index into the first column of the DataFrame.\n\n        Args:\n            name (str): Column name for the index column.\n\n        Returns:\n            self: Modified DataFrame with index as the first column.\n        \"\"\"\n        if self.index is None:\n            raise ValueError(\"No index is set to reset.\")\n\n        # Insert the index values as the first column in each row\n        self.data = [Vector([self.index[i]] + list(row)) for i, row in enumerate(self.data)]\n\n        # Insert the column name for the index\n        self.columns = [name] + self.columns\n\n        # Clear the index\n        self.index = range(len(self.data))\n        return self\n\n    def __len__(self):\n        \"\"\"\n        Return the number of rows in the DataFrame.\n\n        Returns:\n            int: Number of rows in the DataFrame.\n        \"\"\"\n        return len(self.data)\n\n    def __getitem__(self, key):\n        \"\"\"\n        Retrieve data from the DataFrame using various types of indexing.\n\n        Args:\n            key (str, int, tuple, slice, Series, DataFrame): Key to retrieve data.\n\n        Returns:\n            Series or DataFrame: Retrieved data based on the key.\n\n        Raises:\n            ValueError: If an invalid key or selector is provided.\n            KeyError: If the key is unsupported.\n        \"\"\"\n        if isinstance(key, str):\n            # Return a column as a list\n            colIndex = self.columns.index(key)\n            return Series([row[colIndex] for row in self.data], index=self.index, name=key)\n        elif isinstance(key, int):\n            # Return a column by index as a list\n            return Series([row[key] for row in self.data], self.columns[key])\n        elif isinstance(key, tuple):\n            # Multi-dimensional slicing\n            rowSelector, colSelector = key\n\n            # Select rows\n            if isinstance(rowSelector, slice):\n                selectedRows = self.data[rowSelector]\n            elif isinstance(rowSelector, int):\n                selectedRows = [self.data[rowSelector]]\n            else:\n                raise ValueError(\"Invalid row selector.\")\n\n            # Select columns\n            if isinstance(colSelector, str):\n                colIndex = self.columns.index(colSelector)\n                return Series([row[colIndex] for row in selectedRows], colSelector)\n            elif isinstance(colSelector, list):\n                colIndices = [self.columns.index(col) for col in colSelector]\n                selectedData = [[row[colIndex] for colIndex in colIndices] for row in selectedRows]\n                return DataFrame(selectedData, [self.columns[i] for i in colIndices])\n            else:\n                raise ValueError(\"Invalid column selector.\")\n        elif isinstance(key, Series):\n            # Boolean indexing\n            filteredData = [row for row, include in zip(self.data, key.data) if include]\n            return DataFrame(filteredData, self.columns)\n        elif isinstance(key, list):\n            # Boolean indexing\n            filteredData = [row for row, include in zip(self.data, key.data) if include]\n            return DataFrame(filteredData, self.columns)\n        elif isinstance(key, slice):\n            # Return rows as a new DataFrame\n            return DataFrame(self.data[key], self.columns)\n        elif isinstance(key, DataFrame):\n            # Boolean indexing\n            if key.data and all(isinstance(row[0], bool) for row in key.data):\n                filteredData = [row for include, row in zip(key.data, self.data) if include[0]]\n                return DataFrame(filteredData, self.columns)\n            else:\n                raise ValueError(\"Boolean indexing requires a DataFrame with boolean values.\")\n        else:\n            raise KeyError(\"Unsupported key: {}\".format(key))\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set values in the DataFrame for a given column.\n\n        Args:\n            key (str): Column name to set values.\n            value (iterable): Values to set in the column.\n\n        Raises:\n            KeyError: If the key is unsupported.\n        \"\"\"\n        if isinstance(key, str):\n            if key in self.columns:\n                colIndex = self.columns.index(key)\n                for rowIndex, val in enumerate(value):\n                    self.data[rowIndex][colIndex] = val\n            else:\n                for rowIndex, val in enumerate(value):\n                    self.data[rowIndex].to_list().append(val)\n                oldCols = self.columns.to_list()\n                oldCols.append(key)\n                self.columns = JIndex(oldCols)\n        else:\n            raise KeyError(\"Unsupported key: {}\".format(key))\n\n    def __eq__(self, other):\n        if not isinstance(other, DataFrame):\n            return False\n        return self.columns == other.columns and self.data == other.data\n\n    def set_item_by_loc(self, key, value):\n        \"\"\"\n        Set values in the DataFrame using .loc indexing.\n\n        Args:\n            key (tuple): Tuple of row and column selectors.\n            value: Value(s) to set in the specified location.\n\n        Raises:\n            ValueError: If the column selector is invalid.\n        \"\"\"\n        if isinstance(key, tuple):\n            rowSelector, colSelector = key\n            if isinstance(rowSelector, slice):\n                rows = range(*rowSelector.indices(len(self.data)))\n            else:\n                rows = [rowSelector]\n\n            if isinstance(colSelector, str):\n                colIndex = self.columns.index(colSelector)\n                for row in rows:\n                    self.data[row][colIndex] = value\n            elif isinstance(colSelector, list):\n                colIndices = [self.columns.index(col) for col in colSelector]\n                for row in rows:\n                    for idx, colIndex in enumerate(colIndices):\n                        self.data[row][colIndex] = value[idx]\n            else:\n                raise ValueError(\"Invalid column selector for .loc\")\n        elif isinstance(key, int):\n            # Setting a whole row\n            if len(value) != len(self.columns):\n                raise ValueError(\"Length of value does not match number of columns.\")\n            if key &lt; len(self.data):\n                self.data[key] = list(value)\n            elif key == len(self.data):\n                self.data.append(list(value))\n        else:\n            raise ValueError(\"Invalid key for .loc\")\n\n    def set_item_by_iloc(self, key, value):\n        \"\"\"\n        Set values in the DataFrame using .iloc indexing.\n\n        Args:\n            key (tuple): A tuple of row and column selectors.\n                - Row selector can be an integer, slice, or list of integers.\n                - Column selector can be an integer, slice, or list of integers.\n            value: Value(s) to set in the specified locations.\n\n        Raises:\n            ValueError: If the column selector is invalid.\n        \"\"\"\n        if isinstance(key, tuple):\n            rowSelector, colSelector = key\n            if isinstance(rowSelector, slice):\n                rows = range(*rowSelector.indices(len(self.data)))\n            else:\n                rows = [rowSelector]\n\n            if isinstance(colSelector, int):\n                for row in rows:\n                    self.data[row][colSelector] = value\n            elif isinstance(colSelector, slice):\n                colIndices = range(*colSelector.indices(len(self.columns)))\n                for row in rows:\n                    for colIndex in colIndices:\n                        self.data[row][colIndex] = value\n            elif isinstance(colSelector, list):\n                for row in rows:\n                    for idx, colIndex in enumerate(colSelector):\n                        self.data[row][colIndex] = value[idx]\n            else:\n                raise ValueError(\"Invalid column selector for .iloc\")\n\n    def get_column(self, columnName):\n        \"\"\"\n        Retrieve a column by name as a Vector.\n\n        Args:\n            columnName (str): The name of the column to retrieve.\n\n        Returns:\n            Vector: The data of the specified column.\n\n        Raises:\n            ValueError: If the column does not exist in the DataFrame.\n        \"\"\"\n        try:\n            # Find the index of the column name in the self.columns list\n            index = self.columns.index(columnName)\n        except ValueError:\n            # If the column is not found, return None\n            return None\n\n        # Return the column name and the corresponding data\n        return Vector([row[index] for row in self.data])\n\n    def astype(self, dtypeOrDict):\n        \"\"\"\n        Cast the DataFrame to the given data type(s).\n\n        Args:\n            dtypeOrDict (type or dict): A single type to cast all columns,\n                                          or a dict mapping column names to types.\n\n        Returns:\n            JDataFrame: A new DataFrame with cast data.\n        \"\"\"\n        newData = []\n        colTypes = {}\n\n        if isinstance(dtypeOrDict, dict):\n            # Explicit mapping of column names to types\n            for col in self.columns:\n                colTypes[col] = dtypeOrDict.get(col, None)\n        else:\n            # One type for all columns\n            for col in self.columns:\n                colTypes[col] = dtypeOrDict\n\n        for row in self.data:\n            newRow = []\n            for i, val in enumerate(row):\n                col = self.columns[i]\n                castType = colTypes.get(col)\n                if castType:\n                    try:\n                        # Treat empty strings and 'NA' as None\n                        if val in (\"\", \"NA\"):\n                            newRow.append(None)\n                        else:\n                            newRow.append(castType(val))\n                    except Exception as e:\n                        raise ValueError(\n                            \"Could not cast column '{}' value '{}' to {}: {}\".format(col, val, castType, e))\n                else:\n                    newRow.append(val)\n            newData.append(Vector(newRow))\n\n        return self.__class__(newData, columns=self.columns, index=self.index)\n\n    def rolling(self, window, min_periods=None):\n        \"\"\"\n           Return a Rolling object for performing rolling window operations.\n\n           Parameters:\n           - window (int): Size of the moving window. Must be &gt;= 1.\n           - min_periods (int, optional): Minimum number of non-null values in the window required to compute a result.\n             Defaults to the window size.\n\n           Returns:\n           - Rolling: An object that supports aggregation methods like .mean(), .sum(), etc.,\n             applied over rolling windows for each column.\n\n           Example:\n           &gt;&gt;&gt; df.rolling(window=3, min_periods=2).mean()\n           \"\"\"\n        return Rolling(self, window, min_periods)\n\n    def to_csv(self, filepath=None):\n        \"\"\"\n        Export the DataFrame to a CSV file or a string.\n\n        Args:\n            filepath (str or None): File path to save the CSV. If None, returns a CSV string.\n\n        Returns:\n            str: CSV data as a string if filepath is None.\n\n        Raises:\n            IOError: If there is an issue writing to the file.\n        \"\"\"\n        if filepath is None:\n            filepath = io.StringIO()  # Create an in-memory string buffer\n\n        # Create a writer object (either to a file or to a StringIO object)\n        if isinstance(filepath, str):\n            with open(filepath, 'w', newline='', encoding='utf-8') as csvfile:\n                writer = csv.writer(csvfile)\n                # Write column headers\n                writer.writerow(self.columns)\n                # Write the data rows\n                for row in self.data:\n                    writer.writerow(row)\n        else:\n            writer = csv.writer(filepath)\n            # Write column headers\n            writer.writerow(self.columns)\n            # Write the data rows\n            for row in self.data:\n                writer.writerow(row)\n\n        # Return the CSV string if we used StringIO\n        if isinstance(filepath, io.StringIO):\n            return filepath.getvalue()\n\n    def iterrows(self):\n        \"\"\"\n        Iterate over the rows of the DataFrame.\n\n        Yields:\n            tuple: A tuple containing the row index and the row data as a Vector.\n        \"\"\"\n        for i, row in enumerate(self.data):\n            # Convert each row to a dictionary with column names as keys and values as Vectors\n            rowVector = Vector([row[j] for j in range(len(row))], name=\"Row {}\".format(i))\n            yield i, rowVector\n\n    def info(self):\n        \"\"\"\n        Print a concise summary of the DataFrame similar to pandas.DataFrame.info().\n        \"\"\"\n        buffer = [\"&lt;class 'Jandas.DataFrame'&gt;\",\n                  \"RangeIndex: {} entries, 0 to {}\".format(len(self.data), len(self.data) - 1),\n                  \"Data columns (total {} columns):\".format(len(self.columns))]\n\n        for i, col in enumerate(self.columns):\n            nonNullCount = sum(row[i] is not None for row in self.data)\n            sampleValue = next((row[i] for row in self.data if row[i] is not None), None)\n            dtype = type(sampleValue).__name__ if sampleValue is not None else 'NoneType'\n            buffer.append(\" {:&lt;3} {:&lt;20} {:&gt;5} non-null   {}\".format(i, col, nonNullCount, dtype))\n\n        buffer.append(\"dtypes: {}\".format(\", \".join(sorted(set(\n            type(row[i]).__name__ for row in self.data for i in range(len(self.columns)) if row[i] is not None\n        )))))\n        print(\"\\n\".join(buffer))\n\n    def copy(self):\n        \"\"\"\n        Create a deep copy of the DataFrame.\n\n        Returns:\n            DataFrame: A new DataFrame object with the same data and columns.\n        \"\"\"\n        return DataFrame([row[:] for row in self.data], self.columns[:])\n\n    def concat(self, other, axis=0):\n        \"\"\"\n        Concatenate two DataFrames along a specified axis.\n\n        Args:\n            other (DataFrame): The DataFrame to concatenate.\n            axis (int): The axis along which to concatenate (0 for rows, 1 for columns).\n\n        Returns:\n            DataFrame: The concatenated DataFrame.\n\n        Raises:\n            ValueError: If the axis is invalid or the DataFrames are incompatible.\n        \"\"\"\n        if axis == 0:  # Concatenate vertically (add rows)\n            return DataFrame(self.data + other.data, self.columns)\n        elif axis == 1:  # Concatenate horizontally (add columns)\n            if len(self.data) != len(other.data):\n                raise ValueError(\"DataFrames must have the same number of rows to concatenate along axis 1\")\n            concatenatedData = [row1 + row2 for row1, row2 in zip(self.data, other.data)]\n            return DataFrame(concatenatedData, self.columns + other.columns)\n        else:\n            raise ValueError(\"Invalid axis value. Axis must be 0 or 1.\")\n\n    def items(self):\n        \"\"\"\n        Iterate over columns of the DataFrame as (columnName, Vector) pairs.\n\n        Yields:\n            tuple: Column name and column data as a Vector.\n        \"\"\"\n        for colIndex, colName in enumerate(self.columns):\n            colData = [row[colIndex] for row in self.data]\n            yield colName, Vector(colData, name=colName)\n\n    def keys(self):\n        \"\"\"\n        Get the column names of the DataFrame.\n\n        Returns:\n            list: A list of column names.\n        \"\"\"\n        return self.columns\n\n    def diff(self, periods=1, axis=0):\n        \"\"\"\n        Calculate the difference between rows or columns.\n\n        Args:\n            periods (int): Periods to shift for calculating difference.\n            axis (int): 0 = row-wise diff (default), 1 = column-wise diff.\n\n        Returns:\n            DataFrame: A new DataFrame of differences.\n        \"\"\"\n        if periods &lt; 1:\n            raise ValueError(\"periods must be &gt;= 1\")\n\n        newData = []\n\n        if axis == 0:\n            # Row-wise diff\n            for i in range(len(self.data)):\n                if i &lt; periods:\n                    newData.append([None] * len(self.columns))\n                else:\n                    prevRow = self.data[i - periods]\n                    currRow = self.data[i]\n                    diffRow = []\n                    for j in range(len(currRow)):\n                        try:\n                            diff = currRow[j] - prevRow[j]\n                        except Exception:\n                            diff = None\n                        diffRow.append(diff)\n                    newData.append(diffRow)\n\n        elif axis == 1:\n            # Column-wise diff\n            for row in self.data:\n                newRow = []\n                for j in range(len(row)):\n                    if j &lt; periods:\n                        newRow.append(None)\n                    else:\n                        try:\n                            diff = row[j] - row[j - periods]\n                        except Exception:\n                            diff = None\n                        newRow.append(diff)\n                newData.append(newRow)\n\n        else:\n            raise ValueError(\"axis must be 0 (rows) or 1 (columns)\")\n\n        return DataFrame(newData, columns=self.columns)\n\n    def pop(self, col):\n        \"\"\"\n        Remove and return a column from the DataFrame.\n\n        Args:\n            col (str): The name of the column to remove.\n\n        Returns:\n            Vector: The data of the removed column.\n\n        Raises:\n            ValueError: If the column does not exist.\n        \"\"\"\n        colIndex = self.columns.index(col)\n        poppedData = [row.pop(colIndex) for row in self.data]\n        self.columns.data.pop(colIndex)\n        return Vector(poppedData)\n\n    def tail(self, n=5):\n        \"\"\"\n        Return the last `n` rows of the DataFrame.\n\n        Parameters:\n        n (int): Number of rows to return from the end of the DataFrame. Default is 5.\n\n        Returns:\n        DataFrame: A new DataFrame containing the last `n` rows.\n        \"\"\"\n        return DataFrame(self.data[-n:], self.columns)\n\n    def get(self, key, default=None):\n        \"\"\"\n        Get the values of a specific column in the DataFrame.\n\n        Parameters:\n        key (str): The column name to retrieve.\n        default: The value to return if the column does not exist. Default is None.\n\n        Returns:\n        Vector or default: A vector of values for the specified column or the default value if the column doesn't exist.\n        \"\"\"\n        if key in self.columns:\n            return Vector([row[self.columns.index(key)] for row in self.data])\n        else:\n            return default\n\n    def isin(self, values):\n        \"\"\"\n        Check if each element in the DataFrame is contained in the provided list of values.\n\n        Parameters:\n        values (iterable): The list or set of values to check for membership.\n\n        Returns:\n        DataFrame: A new DataFrame where each cell is a boolean indicating whether the value is in `values`.\n        \"\"\"\n        result = []\n        for row in self.data:\n            result.append([cell in values for cell in row])\n        return DataFrame(result, self.columns)\n\n    def apply(self, func, axis=0):\n        \"\"\"\n        Apply a function element-wise across a column or row.\n\n        Parameters:\n        func (function): The function to apply to the data.\n        axis (int): Axis along which the function is applied. 0 for columns, 1 for rows.\n\n        Returns:\n        DataFrame: A new DataFrame with the function applied.\n\n        Raises:\n        ValueError: If the axis is not 0 or 1.\n        \"\"\"\n        if axis == 0:  # Apply function to each column\n            cols = list(zip(*self.data))  # Transpose rows to columns\n            applied = [func(list(col)) for col in cols]\n            return DataFrame([applied], columns=self.columns)\n        elif axis == 1:  # Apply function to each row\n            applied = [func(row) for row in self.data]\n            return DataFrame([[val] for val in applied], columns=[\"result\"], index=self.index)\n        else:\n            raise ValueError(\"Axis must be 0 (columns) or 1 (rows).\")\n\n    def applymap(self, func):\n        \"\"\"\n        Apply a function element-wise to all elements in the DataFrame.\n\n        Parameters:\n        func (function): The function to apply to each element.\n\n        Returns:\n        DataFrame: A new DataFrame with the function applied element-wise to each value.\n        \"\"\"\n        return DataFrame([[func(value) for value in row.as_array()] for row in self.data], self.columns)\n\n    def map(self, func):\n        \"\"\"\n        Apply a function element-wise to each row in the DataFrame.\n\n        Parameters:\n        func (function): The function to apply to each row.\n\n        Returns:\n        DataFrame: A new DataFrame with the function applied to each element in each row.\n        \"\"\"\n        return DataFrame([[func(value) for value in row] for row in self.data], self.columns)\n\n    def groupby(self, columnNames, numericOnly=False):\n        \"\"\"\n        Group the DataFrame by one or more columns.\n\n        Parameters:\n        columnNames (str | list): Column name or list of column names to group by.\n        numericOnly (bool): Whether to include only numeric columns in aggregations.\n\n        Returns:\n        GroupBy: GroupBy object.\n        \"\"\"\n        if isinstance(columnNames, str):\n            columnNames = [columnNames]\n\n        try:\n            indices = [self.columns.index(col) for col in columnNames]\n        except ValueError:\n            return None\n\n        groups = {}\n        for row in self.data:\n            key = tuple(row[i] for i in indices)\n            if key not in groups:\n                groups[key] = []\n            groups[key].append(row)\n\n        return GroupBy(groups, self.columns, groupbyColumnIndices=indices, numericOnly=numericOnly)\n\n    def corr(self):\n        \"\"\"\n        Compute the Pearson correlation matrix of the DataFrame.\n\n        Returns:\n            DataFrame: Correlation matrix as a new DataFrame with columns and index as the original columns.\n        \"\"\"\n\n        def mean(values):\n            return sum(values) / len(values)\n\n        def stddev(values, ddof=1):\n            m = mean(values)\n            variance = sum((x - m) ** 2 for x in values) / (len(values) - ddof)\n            return variance ** 0.5\n\n        def pearsonCorr(x, y):\n            meanX = mean(x)\n            meanY = mean(y)\n            numerator = sum((a - meanX) * (b - meanY) for a, b in zip(x, y))\n            denominator = (sum((a - meanX) ** 2 for a in x) * sum((b - meanY) ** 2 for b in y)) ** 0.5\n            if denominator == 0:\n                return 0  # or None or float('nan'), depending on your choice\n            return numerator / denominator\n\n        cols = self.columns\n        n = len(cols)\n        # transpose data to get columns as lists\n        columnsData = list(zip(*self.data))\n        corrMatrix = []\n\n        for i in range(n):\n            rowCorr = []\n            for j in range(n):\n                corrValue = pearsonCorr(columnsData[i], columnsData[j])\n                rowCorr.append(corrValue)\n            corrMatrix.append(rowCorr)\n\n        # Return as a DataFrame with columns and index\n        return DataFrame(data=corrMatrix, columns=cols, index=cols)\n\n    def count(self):\n        \"\"\"\n        Count the number of non-null values in each column of the DataFrame.\n\n        Returns:\n        list: A list of counts for each column, where each count corresponds to the number of non-null values.\n        \"\"\"\n        return Series([sum(1 for row in self.data if row[colIndex] is not None) for colIndex in\n                       range(len(self.columns))], index=self.columns)\n\n    def describe(self):\n        \"\"\"\n        Generate descriptive statistics of the DataFrame.\n\n        Returns:\n            DataFrame: A DataFrame where each row is a statistic (mean, std, etc.)\n                       and each column is a column in the original data.\n        \"\"\"\n        stats = {\n            \"count\": [],\n            \"mean\": [],\n            \"std\": [],\n            \"min\": [],\n            \"25%\": [],\n            \"50%\": [],\n            \"75%\": [],\n            \"max\": []\n        }\n\n        # Calculate stats for each column\n        for colIndex in range(len(self.columns)):\n            columnData = [row[colIndex] for row in self.data if isinstance(row[colIndex], (int, float))]\n            if columnData:\n                stats[\"count\"].append(len(columnData))\n                stats[\"mean\"].append(sum(columnData) / len(columnData))\n                stats[\"std\"].append(self._std(columnData))\n                stats[\"min\"].append(min(columnData))\n                stats[\"25%\"].append(self._percentile(columnData, 25))\n                stats[\"50%\"].append(self._percentile(columnData, 50))\n                stats[\"75%\"].append(self._percentile(columnData, 75))\n                stats[\"max\"].append(max(columnData))\n            else:\n                for key in stats:\n                    stats[key].append(None)\n\n        # Transpose to make stats the row index\n        data = [[stats[stat][i] for stat in stats] for i in range(len(self.columns))]\n        df = DataFrame(data, columns=list(stats.keys()))\n        df.index = self.columns\n        df_T = df.transpose()\n        return df_T\n\n    def max(self):\n        \"\"\"Return the maximum value for each column in the DataFrame.\"\"\"\n        return Series([max([row[colIndex] for row in self.data if row[colIndex] is not None]) for colIndex in\n                       range(len(self.columns))], index=self.columns)\n\n    def mean(self, axis=0):\n        \"\"\"Return the mean of the DataFrame's columns (axis=0) or rows (axis=1).\n\n        Parameters:\n        axis (int): Axis to calculate mean over. 0 for columns, 1 for rows.\n\n        Returns:\n        List: Mean values for columns or rows. Returns None for any row/column with no numeric values.\n\n        Raises:\n        ValueError: If axis is not 0 or 1.\n        \"\"\"\n\n        def safeMean(values):\n            numeric = [v for v in values if isinstance(v, (int, float))]\n            return sum(numeric) / len(numeric) if numeric else None\n\n        if axis == 0:\n            return Series([safeMean(col) for col in zip(*self.values)], index=self.columns)\n        elif axis == 1:\n            return Series([safeMean(row) for row in self.data], index=self.columns)\n        else:\n            raise ValueError(\"Axis must be 0 (columns) or 1 (rows).\")\n\n    def median(self):\n        \"\"\"Return the median value for each column in the DataFrame.\"\"\"\n        return Series([sorted([row[colIndex] for row in self.data if row[colIndex] is not None])[len(self.data) // 2]\n                       for colIndex in range(len(self.columns))], index=self.columns)\n\n    def min(self):\n        \"\"\"Return the minimum value for each column in the DataFrame.\"\"\"\n        return Series([min([row[colIndex] for row in self.data if row[colIndex] is not None]) for colIndex in\n                       range(len(self.columns))], index=self.columns)\n\n    def mode(self):\n        \"\"\"Return a new DataFrame with the mode(s) for each column.\"\"\"\n        from collections import Counter\n\n        modeLists = []\n        for colIndex in range(len(self.columns)):\n            columnData = [row[colIndex] for row in self.data]\n            counter = Counter(columnData)\n            if not counter:\n                modeLists.append([None])\n                continue\n\n            mostCommon = counter.most_common()\n            maxCount = mostCommon[0][1]\n            tiedValues = [value for value, count in mostCommon if count == maxCount]\n\n            modeLists.append(tiedValues)\n\n        # Find the longest mode list so we can pad shorter ones\n        maxLen = max(len(modes) for modes in modeLists)\n\n        # Transpose and pad with None\n        resultData = []\n        for i in range(maxLen):\n            row = [modes[i] if i &lt; len(modes) else None for modes in modeLists]\n            resultData.append(row)\n\n        return DataFrame(resultData, self.columns)\n\n    def quantile(self, q, axis=0):\n        \"\"\"\n        Return the q-th quantile value along the specified axis.\n\n        Parameters:\n        q (float): Quantile value to calculate (between 0 and 1).\n        axis (int): Axis to compute quantile on.\n                    0 = column-wise (default), 1 = row-wise\n\n        Returns:\n        List: Quantile values for each column (axis=0) or row (axis=1)\n        \"\"\"\n        if not 0 &lt;= q &lt;= 1:\n            raise ValueError(\"Quantile 'q' must be between 0 and 1.\")\n\n        def getQuantile(arr):\n            arr = [v for v in arr if v is not None]\n            if not arr:\n                return None\n            sortedArr = sorted(arr)\n            index = int(len(sortedArr) * q)\n            # Clamp to last index to avoid out-of-range\n            index = min(index, len(sortedArr) - 1)\n            return sortedArr[index]\n\n        if axis == 0:\n            # Compute quantile for each column\n            return [\n                getQuantile([row[i] for row in self.data])\n                for i in range(len(self.columns))\n            ]\n        elif axis == 1:\n            # Compute quantile for each row\n            return [\n                getQuantile(row)\n                for row in self.data\n            ]\n        else:\n            raise ValueError(\"Axis must be 0 (columns) or 1 (rows)\")\n\n    def sum(self, axis=0):\n        \"\"\"Return the sum of the DataFrame's columns (axis=0) or rows (axis=1).\n\n        Ignores non-numeric values (like strings or None).\n\n        Parameters:\n        axis (int): 0 for column-wise sum, 1 for row-wise sum.\n\n        Returns:\n        List[float]: Sum values for columns or rows.\n        \"\"\"\n        if axis == 0:\n            # Sum each column, ignoring non-numeric values\n            return Series([\n                sum(val for val in col if isinstance(val, (int, float)))\n                for col in zip(*self.values)\n            ], index=self.columns)\n        elif axis == 1:\n            # Sum each row, ignoring non-numeric values\n            return Series([\n                sum(val for val in row.as_array() if isinstance(val, (int, float)))\n                for row in self.data\n            ], index=self.index)\n        else:\n            raise ValueError(\"Axis must be 0 (columns) or 1 (rows).\")\n\n    def __truediv__(self, other):\n        \"\"\"\n        Support division of the DataFrame by a scalar (e.g., df / 1000).\n        \"\"\"\n        if isinstance(other, (int, float)):\n            newData = [row / other for row in self.data]\n            return DataFrame(newData, columns=self.columns, index=self.index)\n        else:\n            raise TypeError(\"Unsupported operand type(s) for /: 'DataFrame' and '{}'\".format(type(other).__name__))\n\n    def std(self):\n        \"\"\"Return the standard deviation for each column in the DataFrame.\n\n        Returns:\n            List[float or None]: Standard deviation for each column.\n                                 Returns None for non-numeric columns or empty columns.\n        \"\"\"\n        from math import sqrt\n\n        stds = []\n        for colIndex in range(len(self.columns)):\n            # Extract the numeric values from this column\n            values = [row[colIndex] for row in self.data if isinstance(row[colIndex], (int, float))]\n            if values:\n                mean = sum(values) / len(values)\n                variance = sum((x - mean) ** 2 for x in values) / (len(values) - 1)\n                stds.append(sqrt(variance))\n            else:\n                stds.append(None)\n        return Series(stds, index=self.index)\n\n    def _std(self, data):\n        \"\"\"Calculate the standard deviation for a given list of numeric values.\n\n        Ignores non-numeric entries.\n\n        Returns:\n            float or None: Standard deviation of the numeric values, or None if none found.\n        \"\"\"\n        values = [x for x in data if isinstance(x, (int, float))]\n        if not values:\n            return None\n        mean = sum(values) / len(values)\n        return (sum((x - mean) ** 2 for x in values) / (len(values) - 1)) ** 0.5\n\n    def _percentile(self, data, percentile):\n        \"\"\"Return the percentile value for a given data list.\"\"\"\n        data = sorted(data)\n        index = ((len(data) - 1) * percentile / 100)\n        if isinstance(index, int):\n            return data[index]\n        else:\n            return (data[index.__floor__()] + data[index.__ceil__()]) / 2\n\n    def nunique(self):\n        \"\"\"Return the number of unique values for each column in the DataFrame.\"\"\"\n        return [len(set(row[colIndex] for row in self.data if row[colIndex] is not None)) for colIndex in\n                range(len(self.columns))]\n\n    def value_counts(self, col):\n        \"\"\"Return the count of unique values for a specific column in the DataFrame.\n\n        Parameters:\n        col (str): The column name to count unique values.\n\n        Returns:\n        Counter: A dictionary-like object with the count of each unique value.\n        \"\"\"\n        from collections import Counter\n        colIndex = self.columns.index(col)\n        return Counter(row[colIndex] for row in self.data if row[colIndex] is not None)\n\n    def drop(self, labels, axis=0):\n        \"\"\"\n        Drop specified rows or columns from the DataFrame.\n\n        Parameters:\n        labels (int or list): The row indices or column names to drop.\n        axis (int): 0 for rows, 1 for columns.\n\n        Returns:\n        DataFrame: A new DataFrame with the specified rows or columns dropped.\n        \"\"\"\n        if not isinstance(labels, list):\n            labels = [labels]\n\n        if axis == 0:\n            # Drop rows by index\n            newData = [row for i, row in enumerate(self.data) if self.Index[i] not in labels]\n            newIndex = [self.Index[i] for i in range(len(self.data)) if self.Index[i] not in labels]\n\n            return DataFrame(newData, self.columns, index=newIndex)\n\n        elif axis == 1:\n            # Drop columns by name\n            colIndices = []\n            for label in labels:\n                matches = [i for i, col in enumerate(self.columns) if col == label]\n                if not matches:\n                    raise KeyError(\"Column '{}' not found.\".format(label))\n                colIndices.extend(matches)\n\n            colIndices = sorted(set(colIndices), reverse=True)\n\n            newData = []\n            for row in self.data:\n                newRow = [val for i, val in enumerate(row) if i not in colIndices]\n                newData.append(newRow)\n\n            newColumns = [col for i, col in enumerate(self.columns) if i not in colIndices]\n\n            return DataFrame(newData, newColumns, index=self.Index)  # Preserve index\n\n        else:\n            raise ValueError(\"axis must be 0 (rows) or 1 (columns)\")\n\n    def dropna(self, axis=0, how='any', subset=None, inplace=False, ignoreIndex=False):\n        \"\"\"\n        Drop rows or columns containing None values.\n\n        Parameters:\n            axis (int): 0 to drop rows, 1 to drop columns.\n            how (str): 'any' (drop if any value is None), or 'all' (drop only if all are None).\n            subset (list): List of column names to consider (only for axis=0).\n            inplace (bool): Whether to modify the DataFrame in place. Default False.\n            ignoreIndex (bool): Whether to reset the row indices (only affects axis=0). Default False.\n\n        Returns:\n            DataFrame or None: New DataFrame with rows or columns dropped, or None if inplace=True.\n\n        Raises:\n            ValueError: If axis is not 0 or 1, or if `how` is not 'any' or 'all'.\n        \"\"\"\n        if how not in ('any', 'all'):\n            raise ValueError(\"how must be 'any' or 'all'\")\n\n        if axis == 0:  # Drop rows\n            if subset is not None:\n                colIndices = [self.columns.index(col) for col in subset]\n            else:\n                colIndices = range(len(self.columns))\n\n            if how == 'any':\n                newData = [row for row in self.data if not any(row[i] is None for i in colIndices)]\n            else:  # how == 'all'\n                newData = [row for row in self.data if not all(row[i] is None for i in colIndices)]\n\n            newColumns = list(self.columns)\n\n            if ignoreIndex:\n                # No row index handling needed unless you maintain an explicit index elsewhere\n                pass\n\n        elif axis == 1:  # Drop columns\n            if subset is not None:\n                raise ValueError(\"subset is only valid when axis=0\")\n\n            if how == 'any':\n                validColumns = [i for i in range(len(self.columns)) if all(row[i] is not None for row in self.data)]\n            else:  # how == 'all'\n                validColumns = [i for i in range(len(self.columns)) if not all(row[i] is None for row in self.data)]\n\n            newData = [[row[i] for i in validColumns] for row in self.data]\n            newColumns = [self.columns[i] for i in validColumns]\n        else:\n            raise ValueError(\"Axis must be 0 (rows) or 1 (columns).\")\n\n        if inplace:\n            self.data = newData\n            self.columns = newColumns\n            return None\n        else:\n            return DataFrame(newData, newColumns)\n\n    def fillna(self, value):\n        \"\"\"Fill all None values in the DataFrame with a specified value.\n\n        Parameters:\n        value (any): The value to replace None with.\n\n        Returns:\n        DataFrame: The DataFrame with None values replaced.\n        \"\"\"\n        self.data = [[cell if cell is not None else value for cell in row] for row in self.data]\n        return self\n\n    def fill(self, value):\n        \"\"\"Alias for fillna.\"\"\"\n        return self.fillna(value)\n\n    def isna(self):\n        \"\"\"Return a DataFrame with boolean values indicating None entries.\"\"\"\n        return DataFrame([Vector([cell is None for cell in row]) for row in self.data], self.columns)\n\n    def isnull(self):\n        \"\"\"Alias for isna.\"\"\"\n        return self.isna()\n\n    def notna(self):\n        \"\"\"Return a DataFrame with boolean values indicating non-None entries.\"\"\"\n        return DataFrame([[cell is not None for cell in row] for row in self.data], self.columns)\n\n    def notnull(self):\n        \"\"\"Alias for notna.\"\"\"\n        return self.notna()\n\n    def replace(self, to_replace, value):\n        \"\"\"\n        Replace occurrences of a specified value or substring in the DataFrame with another value.\n\n        Parameters:\n        to_replace (any or str): The value or substring to replace.\n        value (any or str): The value to replace with.\n\n        Returns:\n        DataFrame: The DataFrame with the replacements made.\n        \"\"\"\n\n        def replaceCell(cell):\n            if isinstance(cell, str) and isinstance(to_replace, str) and to_replace in cell:\n                return cell.replace(to_replace, value)\n            elif cell == to_replace:\n                return value\n            return cell\n\n        self.data = [[replaceCell(cell) for cell in row] for row in self.data]\n        return self\n\n    def sort_values(self, by, ascending=True):\n        \"\"\"Sort the DataFrame by a specified column.\n\n        Parameters:\n        by (str): The column name to sort by.\n        ascending (bool): Whether to sort in ascending order.\n\n        Returns:\n        DataFrame: The sorted DataFrame.\n        \"\"\"\n        colIndex = self.columns.index(by)\n        self.data.sort(key=lambda x: x[colIndex], reverse=not ascending)\n        return self\n\n    def sort_index(self, axis=0, ascending=True):\n        \"\"\"Sort the DataFrame by row or column index.\n\n        Parameters:\n        axis (int): Axis to sort by. 0 for rows, 1 for columns.\n        ascending (bool): Whether to sort in ascending order.\n\n        Returns:\n        DataFrame: The sorted DataFrame.\n        \"\"\"\n        # Sort rows by index\n        if axis == 0:\n            sortedPairs = sorted(zip(self.index, self.data), key=lambda pair: pair[0], reverse=not ascending)\n            newIndex, newData = zip(*sortedPairs)\n            return DataFrame(list(newData), columns=self.columns, index=JIndex(list(newIndex)))\n        elif axis == 1:\n            # Sort columns alphabetically\n            sortedIndices = sorted(range(len(self.columns)), key=lambda i: self.columns[i], reverse=not ascending)\n            newColumns = [self.columns[i] for i in sortedIndices]\n            newData = [[row[i] for i in sortedIndices] for row in self.data]\n            return DataFrame(newData, columns=newColumns, index=self.index)\n        else:\n            raise ValueError(\"axis must be 0 (rows) or 1 (columns)\")\n\n    def T(self):\n        \"\"\"Return the transpose of the DataFrame.\"\"\"\n        return self.transpose()\n\n    def transpose(self):\n        \"\"\"Return the transpose of the DataFrame, similar to pandas.DataFrame.T.\"\"\"\n\n        # Ensure columns are strings\n        self.columns = [str(col) for col in self.columns]\n\n        # First, extract the values as a list of lists (convert any Row object to an array)\n        values = [row.as_array() if hasattr(row, 'as_array') else row for row in self.data]\n\n        # Transpose the data\n        transposedData = list(map(list, zip(*values)))\n\n        # Use original columns as new index, and row indices as new columns\n        newColumns = self.index\n        newIndex = self.columns\n\n        # Create the transposed DataFrame\n        df_t = DataFrame(transposedData, columns=newColumns)\n        df_t.index = JIndex(newIndex)\n        if isinstance(df_t.columns, range):\n            df_t.columns = list(df_t.columns)\n        return df_t\n\n    def join(self, other, on=None, how='left', lsuffix='', rsuffix=''):\n        \"\"\"\n        Join the DataFrame with another DataFrame.\n\n        Parameters:\n        - other (DataFrame): The DataFrame to join with.\n        - on (str): The column to join on. If None, join on the first column.\n        - how (str): The type of join. Only 'left' join is currently supported.\n        - lsuffix (str): Suffix to use for overlapping column names in the left DataFrame.\n        - rsuffix (str): Suffix to use for overlapping column names in the right DataFrame.\n\n        Returns:\n        - DataFrame: The joined DataFrame.\n\n        Raises:\n        - NotImplementedError: If 'how' is not 'left'.\n        \"\"\"\n        if how == 'left':\n            # Handle column name collisions\n            overlapping = set(self.columns) &amp; set(other.columns)\n            newSelfColumns = [col + lsuffix if col in overlapping else col for col in self.columns]\n            newOtherColumns = [col + rsuffix if col in overlapping else col for col in other.columns]\n\n            joinedData = []\n            for row in self.data:\n                if on:\n                    joinValue = row[self.columns.index(on)]\n                    matchingRow = next((r for r in other.data if r[other.columns.index(on)] == joinValue), [])\n                    # If no matching row, fill with None for the other columns\n                    if matchingRow is None:\n                        matchingRow = [None] * len(other.columns)\n                else:\n                    matchingRow = other.data[0] if other.data else [None] * len(other.columns)\n                joinedData.append(row + matchingRow)\n            joinedColumns = newSelfColumns + newOtherColumns\n            return DataFrame(joinedData, joinedColumns)\n        else:\n            raise NotImplementedError(\"Only 'left' join is currently implemented\")\n\n    def to_string(self):\n        \"\"\"\n        Convert the DataFrame to a formatted string representation.\n\n        This method converts the data in the DataFrame into a string format, aligning columns based on the maximum\n        width of the values in each column. The column headers are included at the top, followed by the data rows.\n        If the data or columns are empty, an empty string is returned.\n\n        Returns:\n            str: A string representation of the DataFrame.\n        \"\"\"\n        # Determine the maximum width of each column for alignment\n        if not self.data or not self.columns:\n            return \"\"\n\n        # Prepare a 2D list for the string representation\n        rows = [[str(item) if item is not None else 'NaN' for item in row] for row in self.data]\n\n        # Add column headers at the top\n        headers = self.columns\n        colWidths = [max(len(str(item)) for item in col) for col in zip(*([headers] + rows))]\n\n        # Format rows with proper spacing\n        formattedRows = [' '.join(header.ljust(colWidths[idx]) for idx, header in enumerate(headers))]\n\n        for row in rows:\n            formattedRows.append(' '.join(row[idx].ljust(colWidths[idx]) for idx in range(len(row))))\n\n        return '\\n'.join(formattedRows)\n\n    def __str__(self):\n        \"\"\"\n        String representation of the DataFrame.\n\n        This method returns the string representation of the DataFrame by calling the `to_string` method.\n        It is used when the `str()` function or print is called on an instance of the DataFrame class.\n\n        Returns:\n            str: A string representation of the DataFrame.\n        \"\"\"\n        return self.to_string()\n\n    def __repr__(self):\n        \"\"\"\n        Official string representation of the DataFrame for debugging.\n\n        This method provides a string representation that is suitable for debugging, showing the column names\n        followed by the data in tab-separated format. This method is used when the `repr()` function is called\n        or when an object is evaluated in an interactive Python session.\n\n        Returns:\n            str: A string representation of the DataFrame in a tabular format.\n        \"\"\"\n        # Create the header row\n        header = \"\\t\".join(self.columns) if self.columns else \"\"\n\n        # Format the rows of data\n        rows = \"\\n\".join(\"\\t\".join(str(cell) for cell in row) for row in self.data)\n\n        # Combine header and rows\n        return \"{}\\n{}\".format(header, rows) if header else rows\n\n    def __add__(self, other):\n        \"\"\"\n        Add another DataFrame or scalar to the DataFrame.\n\n        If another DataFrame is provided, the corresponding values from both DataFrames are added element-wise. \n        If a scalar (int or float) is provided, the scalar is added to every element of the DataFrame.\n\n        Args:\n            other (DataFrame, int, float): The DataFrame or scalar to add.\n\n        Returns:\n            DataFrame: A new DataFrame with the result of the addition.\n\n        Raises:\n            ValueError: If the DataFrames have different shapes.\n            TypeError: If the operand is not a DataFrame or scalar.\n        \"\"\"\n        if isinstance(other, DataFrame):\n            if len(self.columns) != len(other.columns) or len(self.data) != len(other.data):\n                raise ValueError(\"DataFrames must have the same shape.\")\n            return DataFrame([[x + y for x, y in zip(row1.as_array(), row2.as_array())]\n                              for row1, row2 in zip(self.data, other.data)], self.columns)\n        elif isinstance(other, (int, float)):\n            return DataFrame([[x + other for x in row.as_array()] for row in self.data], self.columns)\n        else:\n            raise TypeError(\"Unsupported operand type.\")\n\n    def __sub__(self, other):\n        \"\"\"\n        Subtract another DataFrame or scalar from the DataFrame.\n\n        If another DataFrame is provided, the corresponding values from both DataFrames are subtracted element-wise. \n        If a scalar (int or float) is provided, the scalar is subtracted from every element of the DataFrame.\n\n        Args:\n            other (DataFrame, int, float): The DataFrame or scalar to subtract.\n\n        Returns:\n            DataFrame: A new DataFrame with the result of the subtraction.\n\n        Raises:\n            ValueError: If the DataFrames have different shapes.\n            TypeError: If the operand is not a DataFrame or scalar.\n        \"\"\"\n        if isinstance(other, DataFrame):\n            if len(self.columns) != len(other.columns) or len(self.data) != len(other.data):\n                raise ValueError(\"DataFrames must have the same shape.\")\n            return DataFrame([[x - y for x, y in zip(row1.as_array(), row2.as_array())]\n                              for row1, row2 in zip(self.data, other.data)], self.columns)\n        elif isinstance(other, (int, float)):\n            return DataFrame([[x - other for x in row.as_array()] for row in self.data], self.columns)\n        else:\n            raise TypeError(\"Unsupported operand type.\")\n\n    def __mul__(self, other):\n        \"\"\"\n        Multiply the DataFrame by another DataFrame or scalar.\n\n        If another DataFrame is provided, the corresponding values from both DataFrames are multiplied element-wise. \n        If a scalar (int or float) is provided, the scalar is multiplied by every element of the DataFrame.\n\n        Args:\n            other (DataFrame, int, float): The DataFrame or scalar to multiply.\n\n        Returns:\n            DataFrame: A new DataFrame with the result of the multiplication.\n\n        Raises:\n            ValueError: If the DataFrames have different shapes.\n            TypeError: If the operand is not a DataFrame or scalar.\n        \"\"\"\n        if isinstance(other, DataFrame):\n            if len(self.columns) != len(other.columns) or len(self.data) != len(other.data):\n                raise ValueError(\"DataFrames must have the same shape.\")\n            return DataFrame([[x * y for x, y in zip(row1.as_array(), row2.as_array())]\n                              for row1, row2 in zip(self.data, other.data)], self.columns)\n        elif isinstance(other, (int, float)):\n            return DataFrame([[x * other for x in row.as_array()] for row in self.data], self.columns)\n        else:\n            raise TypeError(\"Unsupported operand type.\")\n\n    def head(self, n=5):\n        \"\"\"\n        Return the first `n` rows of the DataFrame.\n\n        This method returns a new DataFrame that contains the first `n` rows of the current DataFrame.\n\n        Args:\n            n (int): The number of rows to return. Defaults to 5.\n\n        Returns:\n            DataFrame: A new DataFrame containing the first `n` rows.\n        \"\"\"\n        return DataFrame(self.data[:n], self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.Index","title":"<code>Index = index</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.columns","title":"<code>columns = JIndex(columns)</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.data","title":"<code>data = [(Vector([None] * len(columns), columns)) for _ in (range(numRows))]</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.index","title":"<code>index</code>  <code>property</code> <code>writable</code>","text":"<p>Returns the index of the DataFrame.</p> <p>If a custom index (Index) has been set, it is returned. Otherwise, a default RangeIndex is returned based on the length of the data.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.ndim","title":"<code>ndim</code>  <code>property</code>","text":"<p>Get the number of dimensions of the DataFrame.</p> <p>Returns: - 2 (always for a DataFrame).</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.size","title":"<code>size</code>  <code>property</code>","text":"<p>Get the total number of elements in the DataFrame.</p> <p>Returns: - Integer representing the total number of elements.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.loc","title":"<code>loc</code>  <code>property</code>","text":"<p>Get a _LocIndexer for label-based indexing.</p> <p>Returns: - _LocIndexer object.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.iloc","title":"<code>iloc</code>  <code>property</code>","text":"<p>Get an _IlocIndexer for position-based indexing.</p> <p>Returns: - _IlocIndexer object.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.axes","title":"<code>axes</code>  <code>property</code>","text":"<p>Get the axes of the DataFrame (index and columns).</p> <p>Returns: - Named tuple containing index and columns as Series objects.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.values","title":"<code>values</code>  <code>property</code>","text":"<p>Get the values of the DataFrame as a 2D list.</p> <p>Returns: - 2D list of values.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Get the shape of the DataFrame.</p> <p>Returns: - Tuple (number of rows, number of columns).</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.dtypes","title":"<code>dtypes</code>  <code>property</code>","text":"<p>Get the data types of each column in the DataFrame.</p> <p>Returns: - List of data types for each column.</p>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__init__","title":"<code>__init__(data=None, columns=None, index=None)</code>","text":"<p>Initialize a DataFrame.</p> <p>Parameters: - data: 2D list or list of Vectors representing rows of data. - columns: List of column names.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __init__(self, data=None, columns=None, index=None):\n    \"\"\"\n    Initialize a DataFrame.\n\n    Parameters:\n    - data: 2D list or list of Vectors representing rows of data.\n    - columns: List of column names.\n    \"\"\"\n    self.Index = index\n\n    if columns is None:\n        columns = []\n    if data is None:\n        # Defer assigning data until we have both index and columns\n        self.columns = JIndex(columns)\n        numRows = len(index) if index is not None else 0\n        self.data = [Vector([None] * len(columns), columns) for _ in range(numRows)]\n        return\n    if isinstance(data, dict):\n        # Dict of columns: convert to list of rows\n        columns = list(data.keys()) if not columns else columns\n        colData = [data.get(col, []) for col in columns]\n        numRows = max(len(col) for col in colData)\n        # pad shorter columns with None\n        paddedCols = [col + [None] * (numRows - len(col)) for col in colData]\n        rows = zip(*paddedCols)\n        self.data = [Vector(list(row), columns) for row in rows]\n        self.columns = JIndex(columns)\n        return\n    elif isinstance(data, list):\n        if len(data) &gt; 0 and isinstance(data[0], Vector):\n            self.data = data\n        else:\n            self.data = [Vector(row, columns) for row in data]\n        self.columns = JIndex(columns)\n        return\n\n    else:\n        raise TypeError(\"Unsupported data type for DataFrame initialization.\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.rowByLabel","title":"<code>rowByLabel(label)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def rowByLabel(self, label):\n    # Handle single-element tuple indexing\n    if self.index and isinstance(self.index[0], tuple) and len(self.index[0]) == 1:\n        label = (label,)\n    idx = self.index.index(label)\n    return self.data[idx]\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.set_index","title":"<code>set_index(columnName, inplace=False)</code>","text":"<p>Set a specified column as the index of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>columnName</code> <code>str</code> <p>Name of the column to set as the index.</p> required <code>inplace</code> <code>bool</code> <p>Whether to modify the DataFrame in place. If False, returns a new DataFrame.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>self</code> <p>If inplace is False, returns a new DataFrame with the index set.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified column name does not exist.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def set_index(self, columnName, inplace=False):\n    \"\"\"\n    Set a specified column as the index of the DataFrame.\n\n    Args:\n        columnName (str): Name of the column to set as the index.\n        inplace (bool): Whether to modify the DataFrame in place. If False, returns a new DataFrame.\n\n    Returns:\n        self: If inplace is False, returns a new DataFrame with the index set.\n\n    Raises:\n        ValueError: If the specified column name does not exist.\n    \"\"\"\n    if columnName not in self.columns:\n        raise ValueError(\"Column '{}' does not exist.\".format(columnName))\n    colIndex = self.columns.index(columnName)\n\n    # Extract the new index values\n    self.index = [row[colIndex] for row in self.data]\n\n    # Create new rows without the index column\n    self.data = [Vector([value for i, value in enumerate(row) if i != colIndex]) for row in self.data]\n\n    # Update the column names\n    self.columns = JIndex([col for i, col in enumerate(self.columns) if i != colIndex])\n    if inplace:\n        return\n    else:\n        return self\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.reset_index","title":"<code>reset_index(name='index')</code>","text":"<p>Move the index into the first column of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Column name for the index column.</p> <code>'index'</code> <p>Returns:</p> Name Type Description <code>self</code> <p>Modified DataFrame with index as the first column.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def reset_index(self, name=\"index\"):\n    \"\"\"\n    Move the index into the first column of the DataFrame.\n\n    Args:\n        name (str): Column name for the index column.\n\n    Returns:\n        self: Modified DataFrame with index as the first column.\n    \"\"\"\n    if self.index is None:\n        raise ValueError(\"No index is set to reset.\")\n\n    # Insert the index values as the first column in each row\n    self.data = [Vector([self.index[i]] + list(row)) for i, row in enumerate(self.data)]\n\n    # Insert the column name for the index\n    self.columns = [name] + self.columns\n\n    # Clear the index\n    self.index = range(len(self.data))\n    return self\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of rows in the DataFrame.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>Number of rows in the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __len__(self):\n    \"\"\"\n    Return the number of rows in the DataFrame.\n\n    Returns:\n        int: Number of rows in the DataFrame.\n    \"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve data from the DataFrame using various types of indexing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>(str, int, tuple, slice, Series, DataFrame)</code> <p>Key to retrieve data.</p> required <p>Returns:</p> Type Description <p>Series or DataFrame: Retrieved data based on the key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid key or selector is provided.</p> <code>KeyError</code> <p>If the key is unsupported.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __getitem__(self, key):\n    \"\"\"\n    Retrieve data from the DataFrame using various types of indexing.\n\n    Args:\n        key (str, int, tuple, slice, Series, DataFrame): Key to retrieve data.\n\n    Returns:\n        Series or DataFrame: Retrieved data based on the key.\n\n    Raises:\n        ValueError: If an invalid key or selector is provided.\n        KeyError: If the key is unsupported.\n    \"\"\"\n    if isinstance(key, str):\n        # Return a column as a list\n        colIndex = self.columns.index(key)\n        return Series([row[colIndex] for row in self.data], index=self.index, name=key)\n    elif isinstance(key, int):\n        # Return a column by index as a list\n        return Series([row[key] for row in self.data], self.columns[key])\n    elif isinstance(key, tuple):\n        # Multi-dimensional slicing\n        rowSelector, colSelector = key\n\n        # Select rows\n        if isinstance(rowSelector, slice):\n            selectedRows = self.data[rowSelector]\n        elif isinstance(rowSelector, int):\n            selectedRows = [self.data[rowSelector]]\n        else:\n            raise ValueError(\"Invalid row selector.\")\n\n        # Select columns\n        if isinstance(colSelector, str):\n            colIndex = self.columns.index(colSelector)\n            return Series([row[colIndex] for row in selectedRows], colSelector)\n        elif isinstance(colSelector, list):\n            colIndices = [self.columns.index(col) for col in colSelector]\n            selectedData = [[row[colIndex] for colIndex in colIndices] for row in selectedRows]\n            return DataFrame(selectedData, [self.columns[i] for i in colIndices])\n        else:\n            raise ValueError(\"Invalid column selector.\")\n    elif isinstance(key, Series):\n        # Boolean indexing\n        filteredData = [row for row, include in zip(self.data, key.data) if include]\n        return DataFrame(filteredData, self.columns)\n    elif isinstance(key, list):\n        # Boolean indexing\n        filteredData = [row for row, include in zip(self.data, key.data) if include]\n        return DataFrame(filteredData, self.columns)\n    elif isinstance(key, slice):\n        # Return rows as a new DataFrame\n        return DataFrame(self.data[key], self.columns)\n    elif isinstance(key, DataFrame):\n        # Boolean indexing\n        if key.data and all(isinstance(row[0], bool) for row in key.data):\n            filteredData = [row for include, row in zip(key.data, self.data) if include[0]]\n            return DataFrame(filteredData, self.columns)\n        else:\n            raise ValueError(\"Boolean indexing requires a DataFrame with boolean values.\")\n    else:\n        raise KeyError(\"Unsupported key: {}\".format(key))\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Set values in the DataFrame for a given column.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Column name to set values.</p> required <code>value</code> <code>iterable</code> <p>Values to set in the column.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is unsupported.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __setitem__(self, key, value):\n    \"\"\"\n    Set values in the DataFrame for a given column.\n\n    Args:\n        key (str): Column name to set values.\n        value (iterable): Values to set in the column.\n\n    Raises:\n        KeyError: If the key is unsupported.\n    \"\"\"\n    if isinstance(key, str):\n        if key in self.columns:\n            colIndex = self.columns.index(key)\n            for rowIndex, val in enumerate(value):\n                self.data[rowIndex][colIndex] = val\n        else:\n            for rowIndex, val in enumerate(value):\n                self.data[rowIndex].to_list().append(val)\n            oldCols = self.columns.to_list()\n            oldCols.append(key)\n            self.columns = JIndex(oldCols)\n    else:\n        raise KeyError(\"Unsupported key: {}\".format(key))\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __eq__(self, other):\n    if not isinstance(other, DataFrame):\n        return False\n    return self.columns == other.columns and self.data == other.data\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.set_item_by_loc","title":"<code>set_item_by_loc(key, value)</code>","text":"<p>Set values in the DataFrame using .loc indexing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>tuple</code> <p>Tuple of row and column selectors.</p> required <code>value</code> <p>Value(s) to set in the specified location.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the column selector is invalid.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def set_item_by_loc(self, key, value):\n    \"\"\"\n    Set values in the DataFrame using .loc indexing.\n\n    Args:\n        key (tuple): Tuple of row and column selectors.\n        value: Value(s) to set in the specified location.\n\n    Raises:\n        ValueError: If the column selector is invalid.\n    \"\"\"\n    if isinstance(key, tuple):\n        rowSelector, colSelector = key\n        if isinstance(rowSelector, slice):\n            rows = range(*rowSelector.indices(len(self.data)))\n        else:\n            rows = [rowSelector]\n\n        if isinstance(colSelector, str):\n            colIndex = self.columns.index(colSelector)\n            for row in rows:\n                self.data[row][colIndex] = value\n        elif isinstance(colSelector, list):\n            colIndices = [self.columns.index(col) for col in colSelector]\n            for row in rows:\n                for idx, colIndex in enumerate(colIndices):\n                    self.data[row][colIndex] = value[idx]\n        else:\n            raise ValueError(\"Invalid column selector for .loc\")\n    elif isinstance(key, int):\n        # Setting a whole row\n        if len(value) != len(self.columns):\n            raise ValueError(\"Length of value does not match number of columns.\")\n        if key &lt; len(self.data):\n            self.data[key] = list(value)\n        elif key == len(self.data):\n            self.data.append(list(value))\n    else:\n        raise ValueError(\"Invalid key for .loc\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.set_item_by_iloc","title":"<code>set_item_by_iloc(key, value)</code>","text":"<p>Set values in the DataFrame using .iloc indexing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>tuple</code> <p>A tuple of row and column selectors. - Row selector can be an integer, slice, or list of integers. - Column selector can be an integer, slice, or list of integers.</p> required <code>value</code> <p>Value(s) to set in the specified locations.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the column selector is invalid.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def set_item_by_iloc(self, key, value):\n    \"\"\"\n    Set values in the DataFrame using .iloc indexing.\n\n    Args:\n        key (tuple): A tuple of row and column selectors.\n            - Row selector can be an integer, slice, or list of integers.\n            - Column selector can be an integer, slice, or list of integers.\n        value: Value(s) to set in the specified locations.\n\n    Raises:\n        ValueError: If the column selector is invalid.\n    \"\"\"\n    if isinstance(key, tuple):\n        rowSelector, colSelector = key\n        if isinstance(rowSelector, slice):\n            rows = range(*rowSelector.indices(len(self.data)))\n        else:\n            rows = [rowSelector]\n\n        if isinstance(colSelector, int):\n            for row in rows:\n                self.data[row][colSelector] = value\n        elif isinstance(colSelector, slice):\n            colIndices = range(*colSelector.indices(len(self.columns)))\n            for row in rows:\n                for colIndex in colIndices:\n                    self.data[row][colIndex] = value\n        elif isinstance(colSelector, list):\n            for row in rows:\n                for idx, colIndex in enumerate(colSelector):\n                    self.data[row][colIndex] = value[idx]\n        else:\n            raise ValueError(\"Invalid column selector for .iloc\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.get_column","title":"<code>get_column(columnName)</code>","text":"<p>Retrieve a column by name as a Vector.</p> <p>Parameters:</p> Name Type Description Default <code>columnName</code> <code>str</code> <p>The name of the column to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Vector</code> <p>The data of the specified column.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the column does not exist in the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def get_column(self, columnName):\n    \"\"\"\n    Retrieve a column by name as a Vector.\n\n    Args:\n        columnName (str): The name of the column to retrieve.\n\n    Returns:\n        Vector: The data of the specified column.\n\n    Raises:\n        ValueError: If the column does not exist in the DataFrame.\n    \"\"\"\n    try:\n        # Find the index of the column name in the self.columns list\n        index = self.columns.index(columnName)\n    except ValueError:\n        # If the column is not found, return None\n        return None\n\n    # Return the column name and the corresponding data\n    return Vector([row[index] for row in self.data])\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.astype","title":"<code>astype(dtypeOrDict)</code>","text":"<p>Cast the DataFrame to the given data type(s).</p> <p>Parameters:</p> Name Type Description Default <code>dtypeOrDict</code> <code>type or dict</code> <p>A single type to cast all columns,                           or a dict mapping column names to types.</p> required <p>Returns:</p> Name Type Description <code>JDataFrame</code> <p>A new DataFrame with cast data.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def astype(self, dtypeOrDict):\n    \"\"\"\n    Cast the DataFrame to the given data type(s).\n\n    Args:\n        dtypeOrDict (type or dict): A single type to cast all columns,\n                                      or a dict mapping column names to types.\n\n    Returns:\n        JDataFrame: A new DataFrame with cast data.\n    \"\"\"\n    newData = []\n    colTypes = {}\n\n    if isinstance(dtypeOrDict, dict):\n        # Explicit mapping of column names to types\n        for col in self.columns:\n            colTypes[col] = dtypeOrDict.get(col, None)\n    else:\n        # One type for all columns\n        for col in self.columns:\n            colTypes[col] = dtypeOrDict\n\n    for row in self.data:\n        newRow = []\n        for i, val in enumerate(row):\n            col = self.columns[i]\n            castType = colTypes.get(col)\n            if castType:\n                try:\n                    # Treat empty strings and 'NA' as None\n                    if val in (\"\", \"NA\"):\n                        newRow.append(None)\n                    else:\n                        newRow.append(castType(val))\n                except Exception as e:\n                    raise ValueError(\n                        \"Could not cast column '{}' value '{}' to {}: {}\".format(col, val, castType, e))\n            else:\n                newRow.append(val)\n        newData.append(Vector(newRow))\n\n    return self.__class__(newData, columns=self.columns, index=self.index)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.rolling","title":"<code>rolling(window, min_periods=None)</code>","text":"<p>Return a Rolling object for performing rolling window operations.</p> <p>Parameters: - window (int): Size of the moving window. Must be &gt;= 1. - min_periods (int, optional): Minimum number of non-null values in the window required to compute a result.   Defaults to the window size.</p> <ul> <li>Rolling: An object that supports aggregation methods like .mean(), .sum(), etc.,   applied over rolling windows for each column.</li> </ul> <p>Example:</p> <p>df.rolling(window=3, min_periods=2).mean()</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def rolling(self, window, min_periods=None):\n    \"\"\"\n       Return a Rolling object for performing rolling window operations.\n\n       Parameters:\n       - window (int): Size of the moving window. Must be &gt;= 1.\n       - min_periods (int, optional): Minimum number of non-null values in the window required to compute a result.\n         Defaults to the window size.\n\n       Returns:\n       - Rolling: An object that supports aggregation methods like .mean(), .sum(), etc.,\n         applied over rolling windows for each column.\n\n       Example:\n       &gt;&gt;&gt; df.rolling(window=3, min_periods=2).mean()\n       \"\"\"\n    return Rolling(self, window, min_periods)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.to_csv","title":"<code>to_csv(filepath=None)</code>","text":"<p>Export the DataFrame to a CSV file or a string.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str or None</code> <p>File path to save the CSV. If None, returns a CSV string.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>CSV data as a string if filepath is None.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If there is an issue writing to the file.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def to_csv(self, filepath=None):\n    \"\"\"\n    Export the DataFrame to a CSV file or a string.\n\n    Args:\n        filepath (str or None): File path to save the CSV. If None, returns a CSV string.\n\n    Returns:\n        str: CSV data as a string if filepath is None.\n\n    Raises:\n        IOError: If there is an issue writing to the file.\n    \"\"\"\n    if filepath is None:\n        filepath = io.StringIO()  # Create an in-memory string buffer\n\n    # Create a writer object (either to a file or to a StringIO object)\n    if isinstance(filepath, str):\n        with open(filepath, 'w', newline='', encoding='utf-8') as csvfile:\n            writer = csv.writer(csvfile)\n            # Write column headers\n            writer.writerow(self.columns)\n            # Write the data rows\n            for row in self.data:\n                writer.writerow(row)\n    else:\n        writer = csv.writer(filepath)\n        # Write column headers\n        writer.writerow(self.columns)\n        # Write the data rows\n        for row in self.data:\n            writer.writerow(row)\n\n    # Return the CSV string if we used StringIO\n    if isinstance(filepath, io.StringIO):\n        return filepath.getvalue()\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.iterrows","title":"<code>iterrows()</code>","text":"<p>Iterate over the rows of the DataFrame.</p> <p>Yields:</p> Name Type Description <code>tuple</code> <p>A tuple containing the row index and the row data as a Vector.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def iterrows(self):\n    \"\"\"\n    Iterate over the rows of the DataFrame.\n\n    Yields:\n        tuple: A tuple containing the row index and the row data as a Vector.\n    \"\"\"\n    for i, row in enumerate(self.data):\n        # Convert each row to a dictionary with column names as keys and values as Vectors\n        rowVector = Vector([row[j] for j in range(len(row))], name=\"Row {}\".format(i))\n        yield i, rowVector\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.info","title":"<code>info()</code>","text":"<p>Print a concise summary of the DataFrame similar to pandas.DataFrame.info().</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def info(self):\n    \"\"\"\n    Print a concise summary of the DataFrame similar to pandas.DataFrame.info().\n    \"\"\"\n    buffer = [\"&lt;class 'Jandas.DataFrame'&gt;\",\n              \"RangeIndex: {} entries, 0 to {}\".format(len(self.data), len(self.data) - 1),\n              \"Data columns (total {} columns):\".format(len(self.columns))]\n\n    for i, col in enumerate(self.columns):\n        nonNullCount = sum(row[i] is not None for row in self.data)\n        sampleValue = next((row[i] for row in self.data if row[i] is not None), None)\n        dtype = type(sampleValue).__name__ if sampleValue is not None else 'NoneType'\n        buffer.append(\" {:&lt;3} {:&lt;20} {:&gt;5} non-null   {}\".format(i, col, nonNullCount, dtype))\n\n    buffer.append(\"dtypes: {}\".format(\", \".join(sorted(set(\n        type(row[i]).__name__ for row in self.data for i in range(len(self.columns)) if row[i] is not None\n    )))))\n    print(\"\\n\".join(buffer))\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.copy","title":"<code>copy()</code>","text":"<p>Create a deep copy of the DataFrame.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A new DataFrame object with the same data and columns.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def copy(self):\n    \"\"\"\n    Create a deep copy of the DataFrame.\n\n    Returns:\n        DataFrame: A new DataFrame object with the same data and columns.\n    \"\"\"\n    return DataFrame([row[:] for row in self.data], self.columns[:])\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.concat","title":"<code>concat(other, axis=0)</code>","text":"<p>Concatenate two DataFrames along a specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DataFrame</code> <p>The DataFrame to concatenate.</p> required <code>axis</code> <code>int</code> <p>The axis along which to concatenate (0 for rows, 1 for columns).</p> <code>0</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>The concatenated DataFrame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the axis is invalid or the DataFrames are incompatible.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def concat(self, other, axis=0):\n    \"\"\"\n    Concatenate two DataFrames along a specified axis.\n\n    Args:\n        other (DataFrame): The DataFrame to concatenate.\n        axis (int): The axis along which to concatenate (0 for rows, 1 for columns).\n\n    Returns:\n        DataFrame: The concatenated DataFrame.\n\n    Raises:\n        ValueError: If the axis is invalid or the DataFrames are incompatible.\n    \"\"\"\n    if axis == 0:  # Concatenate vertically (add rows)\n        return DataFrame(self.data + other.data, self.columns)\n    elif axis == 1:  # Concatenate horizontally (add columns)\n        if len(self.data) != len(other.data):\n            raise ValueError(\"DataFrames must have the same number of rows to concatenate along axis 1\")\n        concatenatedData = [row1 + row2 for row1, row2 in zip(self.data, other.data)]\n        return DataFrame(concatenatedData, self.columns + other.columns)\n    else:\n        raise ValueError(\"Invalid axis value. Axis must be 0 or 1.\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.items","title":"<code>items()</code>","text":"<p>Iterate over columns of the DataFrame as (columnName, Vector) pairs.</p> <p>Yields:</p> Name Type Description <code>tuple</code> <p>Column name and column data as a Vector.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def items(self):\n    \"\"\"\n    Iterate over columns of the DataFrame as (columnName, Vector) pairs.\n\n    Yields:\n        tuple: Column name and column data as a Vector.\n    \"\"\"\n    for colIndex, colName in enumerate(self.columns):\n        colData = [row[colIndex] for row in self.data]\n        yield colName, Vector(colData, name=colName)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.keys","title":"<code>keys()</code>","text":"<p>Get the column names of the DataFrame.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of column names.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def keys(self):\n    \"\"\"\n    Get the column names of the DataFrame.\n\n    Returns:\n        list: A list of column names.\n    \"\"\"\n    return self.columns\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.diff","title":"<code>diff(periods=1, axis=0)</code>","text":"<p>Calculate the difference between rows or columns.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>Periods to shift for calculating difference.</p> <code>1</code> <code>axis</code> <code>int</code> <p>0 = row-wise diff (default), 1 = column-wise diff.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A new DataFrame of differences.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def diff(self, periods=1, axis=0):\n    \"\"\"\n    Calculate the difference between rows or columns.\n\n    Args:\n        periods (int): Periods to shift for calculating difference.\n        axis (int): 0 = row-wise diff (default), 1 = column-wise diff.\n\n    Returns:\n        DataFrame: A new DataFrame of differences.\n    \"\"\"\n    if periods &lt; 1:\n        raise ValueError(\"periods must be &gt;= 1\")\n\n    newData = []\n\n    if axis == 0:\n        # Row-wise diff\n        for i in range(len(self.data)):\n            if i &lt; periods:\n                newData.append([None] * len(self.columns))\n            else:\n                prevRow = self.data[i - periods]\n                currRow = self.data[i]\n                diffRow = []\n                for j in range(len(currRow)):\n                    try:\n                        diff = currRow[j] - prevRow[j]\n                    except Exception:\n                        diff = None\n                    diffRow.append(diff)\n                newData.append(diffRow)\n\n    elif axis == 1:\n        # Column-wise diff\n        for row in self.data:\n            newRow = []\n            for j in range(len(row)):\n                if j &lt; periods:\n                    newRow.append(None)\n                else:\n                    try:\n                        diff = row[j] - row[j - periods]\n                    except Exception:\n                        diff = None\n                    newRow.append(diff)\n            newData.append(newRow)\n\n    else:\n        raise ValueError(\"axis must be 0 (rows) or 1 (columns)\")\n\n    return DataFrame(newData, columns=self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.pop","title":"<code>pop(col)</code>","text":"<p>Remove and return a column from the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>str</code> <p>The name of the column to remove.</p> required <p>Returns:</p> Name Type Description <code>Vector</code> <p>The data of the removed column.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the column does not exist.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def pop(self, col):\n    \"\"\"\n    Remove and return a column from the DataFrame.\n\n    Args:\n        col (str): The name of the column to remove.\n\n    Returns:\n        Vector: The data of the removed column.\n\n    Raises:\n        ValueError: If the column does not exist.\n    \"\"\"\n    colIndex = self.columns.index(col)\n    poppedData = [row.pop(colIndex) for row in self.data]\n    self.columns.data.pop(colIndex)\n    return Vector(poppedData)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.tail","title":"<code>tail(n=5)</code>","text":"<p>Return the last <code>n</code> rows of the DataFrame.</p> <p>Parameters: n (int): Number of rows to return from the end of the DataFrame. Default is 5.</p> <p>Returns: DataFrame: A new DataFrame containing the last <code>n</code> rows.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def tail(self, n=5):\n    \"\"\"\n    Return the last `n` rows of the DataFrame.\n\n    Parameters:\n    n (int): Number of rows to return from the end of the DataFrame. Default is 5.\n\n    Returns:\n    DataFrame: A new DataFrame containing the last `n` rows.\n    \"\"\"\n    return DataFrame(self.data[-n:], self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.get","title":"<code>get(key, default=None)</code>","text":"<p>Get the values of a specific column in the DataFrame.</p> <p>Parameters: key (str): The column name to retrieve. default: The value to return if the column does not exist. Default is None.</p> <p>Returns: Vector or default: A vector of values for the specified column or the default value if the column doesn't exist.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def get(self, key, default=None):\n    \"\"\"\n    Get the values of a specific column in the DataFrame.\n\n    Parameters:\n    key (str): The column name to retrieve.\n    default: The value to return if the column does not exist. Default is None.\n\n    Returns:\n    Vector or default: A vector of values for the specified column or the default value if the column doesn't exist.\n    \"\"\"\n    if key in self.columns:\n        return Vector([row[self.columns.index(key)] for row in self.data])\n    else:\n        return default\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.isin","title":"<code>isin(values)</code>","text":"<p>Check if each element in the DataFrame is contained in the provided list of values.</p> <p>Parameters: values (iterable): The list or set of values to check for membership.</p> <p>Returns: DataFrame: A new DataFrame where each cell is a boolean indicating whether the value is in <code>values</code>.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def isin(self, values):\n    \"\"\"\n    Check if each element in the DataFrame is contained in the provided list of values.\n\n    Parameters:\n    values (iterable): The list or set of values to check for membership.\n\n    Returns:\n    DataFrame: A new DataFrame where each cell is a boolean indicating whether the value is in `values`.\n    \"\"\"\n    result = []\n    for row in self.data:\n        result.append([cell in values for cell in row])\n    return DataFrame(result, self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.apply","title":"<code>apply(func, axis=0)</code>","text":"<p>Apply a function element-wise across a column or row.</p> <p>Parameters: func (function): The function to apply to the data. axis (int): Axis along which the function is applied. 0 for columns, 1 for rows.</p> <p>Returns: DataFrame: A new DataFrame with the function applied.</p> <p>Raises: ValueError: If the axis is not 0 or 1.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def apply(self, func, axis=0):\n    \"\"\"\n    Apply a function element-wise across a column or row.\n\n    Parameters:\n    func (function): The function to apply to the data.\n    axis (int): Axis along which the function is applied. 0 for columns, 1 for rows.\n\n    Returns:\n    DataFrame: A new DataFrame with the function applied.\n\n    Raises:\n    ValueError: If the axis is not 0 or 1.\n    \"\"\"\n    if axis == 0:  # Apply function to each column\n        cols = list(zip(*self.data))  # Transpose rows to columns\n        applied = [func(list(col)) for col in cols]\n        return DataFrame([applied], columns=self.columns)\n    elif axis == 1:  # Apply function to each row\n        applied = [func(row) for row in self.data]\n        return DataFrame([[val] for val in applied], columns=[\"result\"], index=self.index)\n    else:\n        raise ValueError(\"Axis must be 0 (columns) or 1 (rows).\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.applymap","title":"<code>applymap(func)</code>","text":"<p>Apply a function element-wise to all elements in the DataFrame.</p> <p>Parameters: func (function): The function to apply to each element.</p> <p>Returns: DataFrame: A new DataFrame with the function applied element-wise to each value.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def applymap(self, func):\n    \"\"\"\n    Apply a function element-wise to all elements in the DataFrame.\n\n    Parameters:\n    func (function): The function to apply to each element.\n\n    Returns:\n    DataFrame: A new DataFrame with the function applied element-wise to each value.\n    \"\"\"\n    return DataFrame([[func(value) for value in row.as_array()] for row in self.data], self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.map","title":"<code>map(func)</code>","text":"<p>Apply a function element-wise to each row in the DataFrame.</p> <p>Parameters: func (function): The function to apply to each row.</p> <p>Returns: DataFrame: A new DataFrame with the function applied to each element in each row.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def map(self, func):\n    \"\"\"\n    Apply a function element-wise to each row in the DataFrame.\n\n    Parameters:\n    func (function): The function to apply to each row.\n\n    Returns:\n    DataFrame: A new DataFrame with the function applied to each element in each row.\n    \"\"\"\n    return DataFrame([[func(value) for value in row] for row in self.data], self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.groupby","title":"<code>groupby(columnNames, numericOnly=False)</code>","text":"<p>Group the DataFrame by one or more columns.</p> <p>Parameters: columnNames (str | list): Column name or list of column names to group by. numericOnly (bool): Whether to include only numeric columns in aggregations.</p> <p>Returns: GroupBy: GroupBy object.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def groupby(self, columnNames, numericOnly=False):\n    \"\"\"\n    Group the DataFrame by one or more columns.\n\n    Parameters:\n    columnNames (str | list): Column name or list of column names to group by.\n    numericOnly (bool): Whether to include only numeric columns in aggregations.\n\n    Returns:\n    GroupBy: GroupBy object.\n    \"\"\"\n    if isinstance(columnNames, str):\n        columnNames = [columnNames]\n\n    try:\n        indices = [self.columns.index(col) for col in columnNames]\n    except ValueError:\n        return None\n\n    groups = {}\n    for row in self.data:\n        key = tuple(row[i] for i in indices)\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(row)\n\n    return GroupBy(groups, self.columns, groupbyColumnIndices=indices, numericOnly=numericOnly)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.corr","title":"<code>corr()</code>","text":"<p>Compute the Pearson correlation matrix of the DataFrame.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Correlation matrix as a new DataFrame with columns and index as the original columns.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def corr(self):\n    \"\"\"\n    Compute the Pearson correlation matrix of the DataFrame.\n\n    Returns:\n        DataFrame: Correlation matrix as a new DataFrame with columns and index as the original columns.\n    \"\"\"\n\n    def mean(values):\n        return sum(values) / len(values)\n\n    def stddev(values, ddof=1):\n        m = mean(values)\n        variance = sum((x - m) ** 2 for x in values) / (len(values) - ddof)\n        return variance ** 0.5\n\n    def pearsonCorr(x, y):\n        meanX = mean(x)\n        meanY = mean(y)\n        numerator = sum((a - meanX) * (b - meanY) for a, b in zip(x, y))\n        denominator = (sum((a - meanX) ** 2 for a in x) * sum((b - meanY) ** 2 for b in y)) ** 0.5\n        if denominator == 0:\n            return 0  # or None or float('nan'), depending on your choice\n        return numerator / denominator\n\n    cols = self.columns\n    n = len(cols)\n    # transpose data to get columns as lists\n    columnsData = list(zip(*self.data))\n    corrMatrix = []\n\n    for i in range(n):\n        rowCorr = []\n        for j in range(n):\n            corrValue = pearsonCorr(columnsData[i], columnsData[j])\n            rowCorr.append(corrValue)\n        corrMatrix.append(rowCorr)\n\n    # Return as a DataFrame with columns and index\n    return DataFrame(data=corrMatrix, columns=cols, index=cols)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.count","title":"<code>count()</code>","text":"<p>Count the number of non-null values in each column of the DataFrame.</p> <p>Returns: list: A list of counts for each column, where each count corresponds to the number of non-null values.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def count(self):\n    \"\"\"\n    Count the number of non-null values in each column of the DataFrame.\n\n    Returns:\n    list: A list of counts for each column, where each count corresponds to the number of non-null values.\n    \"\"\"\n    return Series([sum(1 for row in self.data if row[colIndex] is not None) for colIndex in\n                   range(len(self.columns))], index=self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.describe","title":"<code>describe()</code>","text":"<p>Generate descriptive statistics of the DataFrame.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A DataFrame where each row is a statistic (mean, std, etc.)        and each column is a column in the original data.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def describe(self):\n    \"\"\"\n    Generate descriptive statistics of the DataFrame.\n\n    Returns:\n        DataFrame: A DataFrame where each row is a statistic (mean, std, etc.)\n                   and each column is a column in the original data.\n    \"\"\"\n    stats = {\n        \"count\": [],\n        \"mean\": [],\n        \"std\": [],\n        \"min\": [],\n        \"25%\": [],\n        \"50%\": [],\n        \"75%\": [],\n        \"max\": []\n    }\n\n    # Calculate stats for each column\n    for colIndex in range(len(self.columns)):\n        columnData = [row[colIndex] for row in self.data if isinstance(row[colIndex], (int, float))]\n        if columnData:\n            stats[\"count\"].append(len(columnData))\n            stats[\"mean\"].append(sum(columnData) / len(columnData))\n            stats[\"std\"].append(self._std(columnData))\n            stats[\"min\"].append(min(columnData))\n            stats[\"25%\"].append(self._percentile(columnData, 25))\n            stats[\"50%\"].append(self._percentile(columnData, 50))\n            stats[\"75%\"].append(self._percentile(columnData, 75))\n            stats[\"max\"].append(max(columnData))\n        else:\n            for key in stats:\n                stats[key].append(None)\n\n    # Transpose to make stats the row index\n    data = [[stats[stat][i] for stat in stats] for i in range(len(self.columns))]\n    df = DataFrame(data, columns=list(stats.keys()))\n    df.index = self.columns\n    df_T = df.transpose()\n    return df_T\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.max","title":"<code>max()</code>","text":"<p>Return the maximum value for each column in the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def max(self):\n    \"\"\"Return the maximum value for each column in the DataFrame.\"\"\"\n    return Series([max([row[colIndex] for row in self.data if row[colIndex] is not None]) for colIndex in\n                   range(len(self.columns))], index=self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.mean","title":"<code>mean(axis=0)</code>","text":"<p>Return the mean of the DataFrame's columns (axis=0) or rows (axis=1).</p> <p>Parameters: axis (int): Axis to calculate mean over. 0 for columns, 1 for rows.</p> <p>Returns: List: Mean values for columns or rows. Returns None for any row/column with no numeric values.</p> <p>Raises: ValueError: If axis is not 0 or 1.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def mean(self, axis=0):\n    \"\"\"Return the mean of the DataFrame's columns (axis=0) or rows (axis=1).\n\n    Parameters:\n    axis (int): Axis to calculate mean over. 0 for columns, 1 for rows.\n\n    Returns:\n    List: Mean values for columns or rows. Returns None for any row/column with no numeric values.\n\n    Raises:\n    ValueError: If axis is not 0 or 1.\n    \"\"\"\n\n    def safeMean(values):\n        numeric = [v for v in values if isinstance(v, (int, float))]\n        return sum(numeric) / len(numeric) if numeric else None\n\n    if axis == 0:\n        return Series([safeMean(col) for col in zip(*self.values)], index=self.columns)\n    elif axis == 1:\n        return Series([safeMean(row) for row in self.data], index=self.columns)\n    else:\n        raise ValueError(\"Axis must be 0 (columns) or 1 (rows).\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.median","title":"<code>median()</code>","text":"<p>Return the median value for each column in the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def median(self):\n    \"\"\"Return the median value for each column in the DataFrame.\"\"\"\n    return Series([sorted([row[colIndex] for row in self.data if row[colIndex] is not None])[len(self.data) // 2]\n                   for colIndex in range(len(self.columns))], index=self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.min","title":"<code>min()</code>","text":"<p>Return the minimum value for each column in the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def min(self):\n    \"\"\"Return the minimum value for each column in the DataFrame.\"\"\"\n    return Series([min([row[colIndex] for row in self.data if row[colIndex] is not None]) for colIndex in\n                   range(len(self.columns))], index=self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.mode","title":"<code>mode()</code>","text":"<p>Return a new DataFrame with the mode(s) for each column.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def mode(self):\n    \"\"\"Return a new DataFrame with the mode(s) for each column.\"\"\"\n    from collections import Counter\n\n    modeLists = []\n    for colIndex in range(len(self.columns)):\n        columnData = [row[colIndex] for row in self.data]\n        counter = Counter(columnData)\n        if not counter:\n            modeLists.append([None])\n            continue\n\n        mostCommon = counter.most_common()\n        maxCount = mostCommon[0][1]\n        tiedValues = [value for value, count in mostCommon if count == maxCount]\n\n        modeLists.append(tiedValues)\n\n    # Find the longest mode list so we can pad shorter ones\n    maxLen = max(len(modes) for modes in modeLists)\n\n    # Transpose and pad with None\n    resultData = []\n    for i in range(maxLen):\n        row = [modes[i] if i &lt; len(modes) else None for modes in modeLists]\n        resultData.append(row)\n\n    return DataFrame(resultData, self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.quantile","title":"<code>quantile(q, axis=0)</code>","text":"<p>Return the q-th quantile value along the specified axis.</p> <p>Parameters: q (float): Quantile value to calculate (between 0 and 1). axis (int): Axis to compute quantile on.             0 = column-wise (default), 1 = row-wise</p> <p>Returns: List: Quantile values for each column (axis=0) or row (axis=1)</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def quantile(self, q, axis=0):\n    \"\"\"\n    Return the q-th quantile value along the specified axis.\n\n    Parameters:\n    q (float): Quantile value to calculate (between 0 and 1).\n    axis (int): Axis to compute quantile on.\n                0 = column-wise (default), 1 = row-wise\n\n    Returns:\n    List: Quantile values for each column (axis=0) or row (axis=1)\n    \"\"\"\n    if not 0 &lt;= q &lt;= 1:\n        raise ValueError(\"Quantile 'q' must be between 0 and 1.\")\n\n    def getQuantile(arr):\n        arr = [v for v in arr if v is not None]\n        if not arr:\n            return None\n        sortedArr = sorted(arr)\n        index = int(len(sortedArr) * q)\n        # Clamp to last index to avoid out-of-range\n        index = min(index, len(sortedArr) - 1)\n        return sortedArr[index]\n\n    if axis == 0:\n        # Compute quantile for each column\n        return [\n            getQuantile([row[i] for row in self.data])\n            for i in range(len(self.columns))\n        ]\n    elif axis == 1:\n        # Compute quantile for each row\n        return [\n            getQuantile(row)\n            for row in self.data\n        ]\n    else:\n        raise ValueError(\"Axis must be 0 (columns) or 1 (rows)\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.sum","title":"<code>sum(axis=0)</code>","text":"<p>Return the sum of the DataFrame's columns (axis=0) or rows (axis=1).</p> <p>Ignores non-numeric values (like strings or None).</p> <p>Parameters: axis (int): 0 for column-wise sum, 1 for row-wise sum.</p> <p>Returns: List[float]: Sum values for columns or rows.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def sum(self, axis=0):\n    \"\"\"Return the sum of the DataFrame's columns (axis=0) or rows (axis=1).\n\n    Ignores non-numeric values (like strings or None).\n\n    Parameters:\n    axis (int): 0 for column-wise sum, 1 for row-wise sum.\n\n    Returns:\n    List[float]: Sum values for columns or rows.\n    \"\"\"\n    if axis == 0:\n        # Sum each column, ignoring non-numeric values\n        return Series([\n            sum(val for val in col if isinstance(val, (int, float)))\n            for col in zip(*self.values)\n        ], index=self.columns)\n    elif axis == 1:\n        # Sum each row, ignoring non-numeric values\n        return Series([\n            sum(val for val in row.as_array() if isinstance(val, (int, float)))\n            for row in self.data\n        ], index=self.index)\n    else:\n        raise ValueError(\"Axis must be 0 (columns) or 1 (rows).\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Support division of the DataFrame by a scalar (e.g., df / 1000).</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __truediv__(self, other):\n    \"\"\"\n    Support division of the DataFrame by a scalar (e.g., df / 1000).\n    \"\"\"\n    if isinstance(other, (int, float)):\n        newData = [row / other for row in self.data]\n        return DataFrame(newData, columns=self.columns, index=self.index)\n    else:\n        raise TypeError(\"Unsupported operand type(s) for /: 'DataFrame' and '{}'\".format(type(other).__name__))\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.std","title":"<code>std()</code>","text":"<p>Return the standard deviation for each column in the DataFrame.</p> <p>Returns:</p> Type Description <p>List[float or None]: Standard deviation for each column.                  Returns None for non-numeric columns or empty columns.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def std(self):\n    \"\"\"Return the standard deviation for each column in the DataFrame.\n\n    Returns:\n        List[float or None]: Standard deviation for each column.\n                             Returns None for non-numeric columns or empty columns.\n    \"\"\"\n    from math import sqrt\n\n    stds = []\n    for colIndex in range(len(self.columns)):\n        # Extract the numeric values from this column\n        values = [row[colIndex] for row in self.data if isinstance(row[colIndex], (int, float))]\n        if values:\n            mean = sum(values) / len(values)\n            variance = sum((x - mean) ** 2 for x in values) / (len(values) - 1)\n            stds.append(sqrt(variance))\n        else:\n            stds.append(None)\n    return Series(stds, index=self.index)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.nunique","title":"<code>nunique()</code>","text":"<p>Return the number of unique values for each column in the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def nunique(self):\n    \"\"\"Return the number of unique values for each column in the DataFrame.\"\"\"\n    return [len(set(row[colIndex] for row in self.data if row[colIndex] is not None)) for colIndex in\n            range(len(self.columns))]\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.value_counts","title":"<code>value_counts(col)</code>","text":"<p>Return the count of unique values for a specific column in the DataFrame.</p> <p>Parameters: col (str): The column name to count unique values.</p> <p>Returns: Counter: A dictionary-like object with the count of each unique value.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def value_counts(self, col):\n    \"\"\"Return the count of unique values for a specific column in the DataFrame.\n\n    Parameters:\n    col (str): The column name to count unique values.\n\n    Returns:\n    Counter: A dictionary-like object with the count of each unique value.\n    \"\"\"\n    from collections import Counter\n    colIndex = self.columns.index(col)\n    return Counter(row[colIndex] for row in self.data if row[colIndex] is not None)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.drop","title":"<code>drop(labels, axis=0)</code>","text":"<p>Drop specified rows or columns from the DataFrame.</p> <p>Parameters: labels (int or list): The row indices or column names to drop. axis (int): 0 for rows, 1 for columns.</p> <p>Returns: DataFrame: A new DataFrame with the specified rows or columns dropped.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def drop(self, labels, axis=0):\n    \"\"\"\n    Drop specified rows or columns from the DataFrame.\n\n    Parameters:\n    labels (int or list): The row indices or column names to drop.\n    axis (int): 0 for rows, 1 for columns.\n\n    Returns:\n    DataFrame: A new DataFrame with the specified rows or columns dropped.\n    \"\"\"\n    if not isinstance(labels, list):\n        labels = [labels]\n\n    if axis == 0:\n        # Drop rows by index\n        newData = [row for i, row in enumerate(self.data) if self.Index[i] not in labels]\n        newIndex = [self.Index[i] for i in range(len(self.data)) if self.Index[i] not in labels]\n\n        return DataFrame(newData, self.columns, index=newIndex)\n\n    elif axis == 1:\n        # Drop columns by name\n        colIndices = []\n        for label in labels:\n            matches = [i for i, col in enumerate(self.columns) if col == label]\n            if not matches:\n                raise KeyError(\"Column '{}' not found.\".format(label))\n            colIndices.extend(matches)\n\n        colIndices = sorted(set(colIndices), reverse=True)\n\n        newData = []\n        for row in self.data:\n            newRow = [val for i, val in enumerate(row) if i not in colIndices]\n            newData.append(newRow)\n\n        newColumns = [col for i, col in enumerate(self.columns) if i not in colIndices]\n\n        return DataFrame(newData, newColumns, index=self.Index)  # Preserve index\n\n    else:\n        raise ValueError(\"axis must be 0 (rows) or 1 (columns)\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.dropna","title":"<code>dropna(axis=0, how='any', subset=None, inplace=False, ignoreIndex=False)</code>","text":"<p>Drop rows or columns containing None values.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>int</code> <p>0 to drop rows, 1 to drop columns.</p> <code>0</code> <code>how</code> <code>str</code> <p>'any' (drop if any value is None), or 'all' (drop only if all are None).</p> <code>'any'</code> <code>subset</code> <code>list</code> <p>List of column names to consider (only for axis=0).</p> <code>None</code> <code>inplace</code> <code>bool</code> <p>Whether to modify the DataFrame in place. Default False.</p> <code>False</code> <code>ignoreIndex</code> <code>bool</code> <p>Whether to reset the row indices (only affects axis=0). Default False.</p> <code>False</code> <p>Returns:</p> Type Description <p>DataFrame or None: New DataFrame with rows or columns dropped, or None if inplace=True.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If axis is not 0 or 1, or if <code>how</code> is not 'any' or 'all'.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def dropna(self, axis=0, how='any', subset=None, inplace=False, ignoreIndex=False):\n    \"\"\"\n    Drop rows or columns containing None values.\n\n    Parameters:\n        axis (int): 0 to drop rows, 1 to drop columns.\n        how (str): 'any' (drop if any value is None), or 'all' (drop only if all are None).\n        subset (list): List of column names to consider (only for axis=0).\n        inplace (bool): Whether to modify the DataFrame in place. Default False.\n        ignoreIndex (bool): Whether to reset the row indices (only affects axis=0). Default False.\n\n    Returns:\n        DataFrame or None: New DataFrame with rows or columns dropped, or None if inplace=True.\n\n    Raises:\n        ValueError: If axis is not 0 or 1, or if `how` is not 'any' or 'all'.\n    \"\"\"\n    if how not in ('any', 'all'):\n        raise ValueError(\"how must be 'any' or 'all'\")\n\n    if axis == 0:  # Drop rows\n        if subset is not None:\n            colIndices = [self.columns.index(col) for col in subset]\n        else:\n            colIndices = range(len(self.columns))\n\n        if how == 'any':\n            newData = [row for row in self.data if not any(row[i] is None for i in colIndices)]\n        else:  # how == 'all'\n            newData = [row for row in self.data if not all(row[i] is None for i in colIndices)]\n\n        newColumns = list(self.columns)\n\n        if ignoreIndex:\n            # No row index handling needed unless you maintain an explicit index elsewhere\n            pass\n\n    elif axis == 1:  # Drop columns\n        if subset is not None:\n            raise ValueError(\"subset is only valid when axis=0\")\n\n        if how == 'any':\n            validColumns = [i for i in range(len(self.columns)) if all(row[i] is not None for row in self.data)]\n        else:  # how == 'all'\n            validColumns = [i for i in range(len(self.columns)) if not all(row[i] is None for row in self.data)]\n\n        newData = [[row[i] for i in validColumns] for row in self.data]\n        newColumns = [self.columns[i] for i in validColumns]\n    else:\n        raise ValueError(\"Axis must be 0 (rows) or 1 (columns).\")\n\n    if inplace:\n        self.data = newData\n        self.columns = newColumns\n        return None\n    else:\n        return DataFrame(newData, newColumns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.fillna","title":"<code>fillna(value)</code>","text":"<p>Fill all None values in the DataFrame with a specified value.</p> <p>Parameters: value (any): The value to replace None with.</p> <p>Returns: DataFrame: The DataFrame with None values replaced.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def fillna(self, value):\n    \"\"\"Fill all None values in the DataFrame with a specified value.\n\n    Parameters:\n    value (any): The value to replace None with.\n\n    Returns:\n    DataFrame: The DataFrame with None values replaced.\n    \"\"\"\n    self.data = [[cell if cell is not None else value for cell in row] for row in self.data]\n    return self\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.fill","title":"<code>fill(value)</code>","text":"<p>Alias for fillna.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def fill(self, value):\n    \"\"\"Alias for fillna.\"\"\"\n    return self.fillna(value)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.isna","title":"<code>isna()</code>","text":"<p>Return a DataFrame with boolean values indicating None entries.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def isna(self):\n    \"\"\"Return a DataFrame with boolean values indicating None entries.\"\"\"\n    return DataFrame([Vector([cell is None for cell in row]) for row in self.data], self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.isnull","title":"<code>isnull()</code>","text":"<p>Alias for isna.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def isnull(self):\n    \"\"\"Alias for isna.\"\"\"\n    return self.isna()\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.notna","title":"<code>notna()</code>","text":"<p>Return a DataFrame with boolean values indicating non-None entries.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def notna(self):\n    \"\"\"Return a DataFrame with boolean values indicating non-None entries.\"\"\"\n    return DataFrame([[cell is not None for cell in row] for row in self.data], self.columns)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.notnull","title":"<code>notnull()</code>","text":"<p>Alias for notna.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def notnull(self):\n    \"\"\"Alias for notna.\"\"\"\n    return self.notna()\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.replace","title":"<code>replace(to_replace, value)</code>","text":"<p>Replace occurrences of a specified value or substring in the DataFrame with another value.</p> <p>Parameters: to_replace (any or str): The value or substring to replace. value (any or str): The value to replace with.</p> <p>Returns: DataFrame: The DataFrame with the replacements made.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def replace(self, to_replace, value):\n    \"\"\"\n    Replace occurrences of a specified value or substring in the DataFrame with another value.\n\n    Parameters:\n    to_replace (any or str): The value or substring to replace.\n    value (any or str): The value to replace with.\n\n    Returns:\n    DataFrame: The DataFrame with the replacements made.\n    \"\"\"\n\n    def replaceCell(cell):\n        if isinstance(cell, str) and isinstance(to_replace, str) and to_replace in cell:\n            return cell.replace(to_replace, value)\n        elif cell == to_replace:\n            return value\n        return cell\n\n    self.data = [[replaceCell(cell) for cell in row] for row in self.data]\n    return self\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.sort_values","title":"<code>sort_values(by, ascending=True)</code>","text":"<p>Sort the DataFrame by a specified column.</p> <p>Parameters: by (str): The column name to sort by. ascending (bool): Whether to sort in ascending order.</p> <p>Returns: DataFrame: The sorted DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def sort_values(self, by, ascending=True):\n    \"\"\"Sort the DataFrame by a specified column.\n\n    Parameters:\n    by (str): The column name to sort by.\n    ascending (bool): Whether to sort in ascending order.\n\n    Returns:\n    DataFrame: The sorted DataFrame.\n    \"\"\"\n    colIndex = self.columns.index(by)\n    self.data.sort(key=lambda x: x[colIndex], reverse=not ascending)\n    return self\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.sort_index","title":"<code>sort_index(axis=0, ascending=True)</code>","text":"<p>Sort the DataFrame by row or column index.</p> <p>Parameters: axis (int): Axis to sort by. 0 for rows, 1 for columns. ascending (bool): Whether to sort in ascending order.</p> <p>Returns: DataFrame: The sorted DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def sort_index(self, axis=0, ascending=True):\n    \"\"\"Sort the DataFrame by row or column index.\n\n    Parameters:\n    axis (int): Axis to sort by. 0 for rows, 1 for columns.\n    ascending (bool): Whether to sort in ascending order.\n\n    Returns:\n    DataFrame: The sorted DataFrame.\n    \"\"\"\n    # Sort rows by index\n    if axis == 0:\n        sortedPairs = sorted(zip(self.index, self.data), key=lambda pair: pair[0], reverse=not ascending)\n        newIndex, newData = zip(*sortedPairs)\n        return DataFrame(list(newData), columns=self.columns, index=JIndex(list(newIndex)))\n    elif axis == 1:\n        # Sort columns alphabetically\n        sortedIndices = sorted(range(len(self.columns)), key=lambda i: self.columns[i], reverse=not ascending)\n        newColumns = [self.columns[i] for i in sortedIndices]\n        newData = [[row[i] for i in sortedIndices] for row in self.data]\n        return DataFrame(newData, columns=newColumns, index=self.index)\n    else:\n        raise ValueError(\"axis must be 0 (rows) or 1 (columns)\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.T","title":"<code>T()</code>","text":"<p>Return the transpose of the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def T(self):\n    \"\"\"Return the transpose of the DataFrame.\"\"\"\n    return self.transpose()\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.transpose","title":"<code>transpose()</code>","text":"<p>Return the transpose of the DataFrame, similar to pandas.DataFrame.T.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def transpose(self):\n    \"\"\"Return the transpose of the DataFrame, similar to pandas.DataFrame.T.\"\"\"\n\n    # Ensure columns are strings\n    self.columns = [str(col) for col in self.columns]\n\n    # First, extract the values as a list of lists (convert any Row object to an array)\n    values = [row.as_array() if hasattr(row, 'as_array') else row for row in self.data]\n\n    # Transpose the data\n    transposedData = list(map(list, zip(*values)))\n\n    # Use original columns as new index, and row indices as new columns\n    newColumns = self.index\n    newIndex = self.columns\n\n    # Create the transposed DataFrame\n    df_t = DataFrame(transposedData, columns=newColumns)\n    df_t.index = JIndex(newIndex)\n    if isinstance(df_t.columns, range):\n        df_t.columns = list(df_t.columns)\n    return df_t\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.join","title":"<code>join(other, on=None, how='left', lsuffix='', rsuffix='')</code>","text":"<p>Join the DataFrame with another DataFrame.</p> <p>Parameters: - other (DataFrame): The DataFrame to join with. - on (str): The column to join on. If None, join on the first column. - how (str): The type of join. Only 'left' join is currently supported. - lsuffix (str): Suffix to use for overlapping column names in the left DataFrame. - rsuffix (str): Suffix to use for overlapping column names in the right DataFrame.</p> <p>Returns: - DataFrame: The joined DataFrame.</p> <p>Raises: - NotImplementedError: If 'how' is not 'left'.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def join(self, other, on=None, how='left', lsuffix='', rsuffix=''):\n    \"\"\"\n    Join the DataFrame with another DataFrame.\n\n    Parameters:\n    - other (DataFrame): The DataFrame to join with.\n    - on (str): The column to join on. If None, join on the first column.\n    - how (str): The type of join. Only 'left' join is currently supported.\n    - lsuffix (str): Suffix to use for overlapping column names in the left DataFrame.\n    - rsuffix (str): Suffix to use for overlapping column names in the right DataFrame.\n\n    Returns:\n    - DataFrame: The joined DataFrame.\n\n    Raises:\n    - NotImplementedError: If 'how' is not 'left'.\n    \"\"\"\n    if how == 'left':\n        # Handle column name collisions\n        overlapping = set(self.columns) &amp; set(other.columns)\n        newSelfColumns = [col + lsuffix if col in overlapping else col for col in self.columns]\n        newOtherColumns = [col + rsuffix if col in overlapping else col for col in other.columns]\n\n        joinedData = []\n        for row in self.data:\n            if on:\n                joinValue = row[self.columns.index(on)]\n                matchingRow = next((r for r in other.data if r[other.columns.index(on)] == joinValue), [])\n                # If no matching row, fill with None for the other columns\n                if matchingRow is None:\n                    matchingRow = [None] * len(other.columns)\n            else:\n                matchingRow = other.data[0] if other.data else [None] * len(other.columns)\n            joinedData.append(row + matchingRow)\n        joinedColumns = newSelfColumns + newOtherColumns\n        return DataFrame(joinedData, joinedColumns)\n    else:\n        raise NotImplementedError(\"Only 'left' join is currently implemented\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.to_string","title":"<code>to_string()</code>","text":"<p>Convert the DataFrame to a formatted string representation.</p> <p>This method converts the data in the DataFrame into a string format, aligning columns based on the maximum width of the values in each column. The column headers are included at the top, followed by the data rows. If the data or columns are empty, an empty string is returned.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A string representation of the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def to_string(self):\n    \"\"\"\n    Convert the DataFrame to a formatted string representation.\n\n    This method converts the data in the DataFrame into a string format, aligning columns based on the maximum\n    width of the values in each column. The column headers are included at the top, followed by the data rows.\n    If the data or columns are empty, an empty string is returned.\n\n    Returns:\n        str: A string representation of the DataFrame.\n    \"\"\"\n    # Determine the maximum width of each column for alignment\n    if not self.data or not self.columns:\n        return \"\"\n\n    # Prepare a 2D list for the string representation\n    rows = [[str(item) if item is not None else 'NaN' for item in row] for row in self.data]\n\n    # Add column headers at the top\n    headers = self.columns\n    colWidths = [max(len(str(item)) for item in col) for col in zip(*([headers] + rows))]\n\n    # Format rows with proper spacing\n    formattedRows = [' '.join(header.ljust(colWidths[idx]) for idx, header in enumerate(headers))]\n\n    for row in rows:\n        formattedRows.append(' '.join(row[idx].ljust(colWidths[idx]) for idx in range(len(row))))\n\n    return '\\n'.join(formattedRows)\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the DataFrame.</p> <p>This method returns the string representation of the DataFrame by calling the <code>to_string</code> method. It is used when the <code>str()</code> function or print is called on an instance of the DataFrame class.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A string representation of the DataFrame.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    String representation of the DataFrame.\n\n    This method returns the string representation of the DataFrame by calling the `to_string` method.\n    It is used when the `str()` function or print is called on an instance of the DataFrame class.\n\n    Returns:\n        str: A string representation of the DataFrame.\n    \"\"\"\n    return self.to_string()\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__repr__","title":"<code>__repr__()</code>","text":"<p>Official string representation of the DataFrame for debugging.</p> <p>This method provides a string representation that is suitable for debugging, showing the column names followed by the data in tab-separated format. This method is used when the <code>repr()</code> function is called or when an object is evaluated in an interactive Python session.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A string representation of the DataFrame in a tabular format.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Official string representation of the DataFrame for debugging.\n\n    This method provides a string representation that is suitable for debugging, showing the column names\n    followed by the data in tab-separated format. This method is used when the `repr()` function is called\n    or when an object is evaluated in an interactive Python session.\n\n    Returns:\n        str: A string representation of the DataFrame in a tabular format.\n    \"\"\"\n    # Create the header row\n    header = \"\\t\".join(self.columns) if self.columns else \"\"\n\n    # Format the rows of data\n    rows = \"\\n\".join(\"\\t\".join(str(cell) for cell in row) for row in self.data)\n\n    # Combine header and rows\n    return \"{}\\n{}\".format(header, rows) if header else rows\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__add__","title":"<code>__add__(other)</code>","text":"<p>Add another DataFrame or scalar to the DataFrame.</p> <p>If another DataFrame is provided, the corresponding values from both DataFrames are added element-wise.  If a scalar (int or float) is provided, the scalar is added to every element of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>(DataFrame, int, float)</code> <p>The DataFrame or scalar to add.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A new DataFrame with the result of the addition.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DataFrames have different shapes.</p> <code>TypeError</code> <p>If the operand is not a DataFrame or scalar.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __add__(self, other):\n    \"\"\"\n    Add another DataFrame or scalar to the DataFrame.\n\n    If another DataFrame is provided, the corresponding values from both DataFrames are added element-wise. \n    If a scalar (int or float) is provided, the scalar is added to every element of the DataFrame.\n\n    Args:\n        other (DataFrame, int, float): The DataFrame or scalar to add.\n\n    Returns:\n        DataFrame: A new DataFrame with the result of the addition.\n\n    Raises:\n        ValueError: If the DataFrames have different shapes.\n        TypeError: If the operand is not a DataFrame or scalar.\n    \"\"\"\n    if isinstance(other, DataFrame):\n        if len(self.columns) != len(other.columns) or len(self.data) != len(other.data):\n            raise ValueError(\"DataFrames must have the same shape.\")\n        return DataFrame([[x + y for x, y in zip(row1.as_array(), row2.as_array())]\n                          for row1, row2 in zip(self.data, other.data)], self.columns)\n    elif isinstance(other, (int, float)):\n        return DataFrame([[x + other for x in row.as_array()] for row in self.data], self.columns)\n    else:\n        raise TypeError(\"Unsupported operand type.\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Subtract another DataFrame or scalar from the DataFrame.</p> <p>If another DataFrame is provided, the corresponding values from both DataFrames are subtracted element-wise.  If a scalar (int or float) is provided, the scalar is subtracted from every element of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>(DataFrame, int, float)</code> <p>The DataFrame or scalar to subtract.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A new DataFrame with the result of the subtraction.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DataFrames have different shapes.</p> <code>TypeError</code> <p>If the operand is not a DataFrame or scalar.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"\n    Subtract another DataFrame or scalar from the DataFrame.\n\n    If another DataFrame is provided, the corresponding values from both DataFrames are subtracted element-wise. \n    If a scalar (int or float) is provided, the scalar is subtracted from every element of the DataFrame.\n\n    Args:\n        other (DataFrame, int, float): The DataFrame or scalar to subtract.\n\n    Returns:\n        DataFrame: A new DataFrame with the result of the subtraction.\n\n    Raises:\n        ValueError: If the DataFrames have different shapes.\n        TypeError: If the operand is not a DataFrame or scalar.\n    \"\"\"\n    if isinstance(other, DataFrame):\n        if len(self.columns) != len(other.columns) or len(self.data) != len(other.data):\n            raise ValueError(\"DataFrames must have the same shape.\")\n        return DataFrame([[x - y for x, y in zip(row1.as_array(), row2.as_array())]\n                          for row1, row2 in zip(self.data, other.data)], self.columns)\n    elif isinstance(other, (int, float)):\n        return DataFrame([[x - other for x in row.as_array()] for row in self.data], self.columns)\n    else:\n        raise TypeError(\"Unsupported operand type.\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Multiply the DataFrame by another DataFrame or scalar.</p> <p>If another DataFrame is provided, the corresponding values from both DataFrames are multiplied element-wise.  If a scalar (int or float) is provided, the scalar is multiplied by every element of the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>(DataFrame, int, float)</code> <p>The DataFrame or scalar to multiply.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A new DataFrame with the result of the multiplication.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DataFrames have different shapes.</p> <code>TypeError</code> <p>If the operand is not a DataFrame or scalar.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __mul__(self, other):\n    \"\"\"\n    Multiply the DataFrame by another DataFrame or scalar.\n\n    If another DataFrame is provided, the corresponding values from both DataFrames are multiplied element-wise. \n    If a scalar (int or float) is provided, the scalar is multiplied by every element of the DataFrame.\n\n    Args:\n        other (DataFrame, int, float): The DataFrame or scalar to multiply.\n\n    Returns:\n        DataFrame: A new DataFrame with the result of the multiplication.\n\n    Raises:\n        ValueError: If the DataFrames have different shapes.\n        TypeError: If the operand is not a DataFrame or scalar.\n    \"\"\"\n    if isinstance(other, DataFrame):\n        if len(self.columns) != len(other.columns) or len(self.data) != len(other.data):\n            raise ValueError(\"DataFrames must have the same shape.\")\n        return DataFrame([[x * y for x, y in zip(row1.as_array(), row2.as_array())]\n                          for row1, row2 in zip(self.data, other.data)], self.columns)\n    elif isinstance(other, (int, float)):\n        return DataFrame([[x * other for x in row.as_array()] for row in self.data], self.columns)\n    else:\n        raise TypeError(\"Unsupported operand type.\")\n</code></pre>"},{"location":"dataframe_dataframe/#Jandas.dataframe.DataFrame.head","title":"<code>head(n=5)</code>","text":"<p>Return the first <code>n</code> rows of the DataFrame.</p> <p>This method returns a new DataFrame that contains the first <code>n</code> rows of the current DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of rows to return. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A new DataFrame containing the first <code>n</code> rows.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def head(self, n=5):\n    \"\"\"\n    Return the first `n` rows of the DataFrame.\n\n    This method returns a new DataFrame that contains the first `n` rows of the current DataFrame.\n\n    Args:\n        n (int): The number of rows to return. Defaults to 5.\n\n    Returns:\n        DataFrame: A new DataFrame containing the first `n` rows.\n    \"\"\"\n    return DataFrame(self.data[:n], self.columns)\n</code></pre>"},{"location":"dataframe_groupby/","title":"API Reference","text":""},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy","title":"<code>Jandas.dataframe.GroupBy</code>","text":"<p>A class to represent grouped data in a DataFrame.</p> <p>Attributes: - groups: Dictionary where keys are group names and values are lists of rows in the group. - columns: List of column names for the grouped data.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>class GroupBy:\n    \"\"\"\n    A class to represent grouped data in a DataFrame.\n\n    Attributes:\n    - groups: Dictionary where keys are group names and values are lists of rows in the group.\n    - columns: List of column names for the grouped data.\n    \"\"\"\n\n    def __init__(self, groups, columns, groupbyColumnIndices, numericOnly=False):\n        \"\"\"\n        Initialize a GroupBy object.\n\n        Parameters:\n        - groups: Dictionary mapping group keys to lists of rows.\n        - columns: List of column names for the grouped data.\n        \"\"\"\n        self.groups = groups  # The grouped data\n        self.columns = columns  # The column names of the DataFrame\n        self.groupbyColumnIndices = groupbyColumnIndices\n        self.groupIndex = JIndex(list(groups.keys()))  # NEW\n        self.numeric_only = numericOnly\n\n    def __getitem__(self, colName):\n        if colName not in self.columns:\n            raise KeyError(\"Column {} not found\".format(colName))\n\n        colIndex = self.columns.index(colName)\n\n        # Build new groups with only the selected column values per row\n        newGroups = {}\n        for key, rows in self.groups.items():\n            # extract just the values of colIndex for each row\n            newGroups[key] = [[row[colIndex]] for row in rows]\n\n        # The new GroupBy only has one column: colName\n        return GroupBy(newGroups, [colName], groupbyColumnIndices=[])\n\n    def mean(self, numeric_only=False):\n        \"\"\"\n        Calculate the mean of each column in each group.\n\n        Parameters:\n        - numericOnly (bool): If True, only include numeric columns.\n\n        Returns:\n        - DataFrame with group keys as index and column means as values.\n        \"\"\"\n        sampleRow = next(iter(self.groups.values()))[0]\n        valueIndices = [\n            i for i in range(len(self.columns))\n            if i not in self.groupbyColumnIndices and (\n                    not numeric_only or isinstance(sampleRow[i], (int, float))\n            )\n        ]\n        valueCols = [self.columns[i] for i in valueIndices]\n\n        data = []\n        for key, group in self.groups.items():\n            row = []\n            for i in valueIndices:\n                try:\n                    values = [float(row[i]) for row in group]\n                    meanVal = sum(values) / len(values)\n                except (ValueError, TypeError):\n                    meanVal = None\n                row.append(meanVal)\n            data.append(row)\n\n        return DataFrame(data, columns=valueCols, index=JIndex(list(self.groups.keys())))\n\n    def sum(self):\n        \"\"\"\n        Calculate the sum of each column in each group.\n\n        Returns:\n        - Dictionary with group keys as keys and lists of column sums as values.\n        \"\"\"\n        data = []\n        for key, group in self.groups.items():\n            row = [\n                sum(float(x) for x in col)\n                for i, col in enumerate(zip(*group))\n                if i not in self.groupbyColumnIndices\n            ]\n            data.append(row)\n        valueCols = [\n            col for i, col in enumerate(self.columns)\n            if i not in self.groupbyColumnIndices\n        ]\n\n        return DataFrame(data, columns=valueCols, index=JIndex(list(self.groups.keys())))\n\n    def count(self):\n        \"\"\"\n        Count the number of elements in each column for each group.\n\n        Returns:\n        - Dictionary with group keys as keys and lists of counts as values.\n        \"\"\"\n        data = []\n        for key, group in self.groups.items():\n            row = [\n                len(col)\n                for i, col in enumerate(zip(*group))\n                if i not in self.groupbyColumnIndices\n            ]\n            data.append(row)\n        valueCols = [\n            col for i, col in enumerate(self.columns)\n            if i not in self.groupbyColumnIndices\n        ]\n\n        return DataFrame(data, columns=valueCols, index=JIndex(list(self.groups.keys())))\n\n    def apply(self, func):\n        \"\"\"\n        Apply a custom function to each column in each group.\n\n        Parameters:\n        - func: Function to apply to each column.\n\n        Returns:\n        - Dictionary with group keys as keys and lists of results as values.\n        \"\"\"\n        data = []\n        for key, group in self.groups.items():\n            row = [\n                func(col)\n                for i, col in enumerate(zip(*group))\n                if i not in self.groupbyColumnIndices\n            ]\n            data.append(row)\n        valueCols = [\n            col for i, col in enumerate(self.columns)\n            if i not in self.groupbyColumnIndices\n        ]\n\n        return DataFrame(data, columns=valueCols, index=JIndex(list(self.groups.keys())))\n\n    def getGroupKeys(self):\n        \"\"\"\n        Get the keys of all groups.\n\n        Returns:\n        - List of group keys.\n        \"\"\"\n        return list(self.groups.keys())\n</code></pre>"},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.groups","title":"<code>groups = groups</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.columns","title":"<code>columns = columns</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.groupbyColumnIndices","title":"<code>groupbyColumnIndices = groupbyColumnIndices</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.groupIndex","title":"<code>groupIndex = JIndex(list(groups.keys()))</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.numeric_only","title":"<code>numeric_only = numericOnly</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.__init__","title":"<code>__init__(groups, columns, groupbyColumnIndices, numericOnly=False)</code>","text":"<p>Initialize a GroupBy object.</p> <p>Parameters: - groups: Dictionary mapping group keys to lists of rows. - columns: List of column names for the grouped data.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __init__(self, groups, columns, groupbyColumnIndices, numericOnly=False):\n    \"\"\"\n    Initialize a GroupBy object.\n\n    Parameters:\n    - groups: Dictionary mapping group keys to lists of rows.\n    - columns: List of column names for the grouped data.\n    \"\"\"\n    self.groups = groups  # The grouped data\n    self.columns = columns  # The column names of the DataFrame\n    self.groupbyColumnIndices = groupbyColumnIndices\n    self.groupIndex = JIndex(list(groups.keys()))  # NEW\n    self.numeric_only = numericOnly\n</code></pre>"},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.__getitem__","title":"<code>__getitem__(colName)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __getitem__(self, colName):\n    if colName not in self.columns:\n        raise KeyError(\"Column {} not found\".format(colName))\n\n    colIndex = self.columns.index(colName)\n\n    # Build new groups with only the selected column values per row\n    newGroups = {}\n    for key, rows in self.groups.items():\n        # extract just the values of colIndex for each row\n        newGroups[key] = [[row[colIndex]] for row in rows]\n\n    # The new GroupBy only has one column: colName\n    return GroupBy(newGroups, [colName], groupbyColumnIndices=[])\n</code></pre>"},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.mean","title":"<code>mean(numeric_only=False)</code>","text":"<p>Calculate the mean of each column in each group.</p> <p>Parameters: - numericOnly (bool): If True, only include numeric columns.</p> <p>Returns: - DataFrame with group keys as index and column means as values.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def mean(self, numeric_only=False):\n    \"\"\"\n    Calculate the mean of each column in each group.\n\n    Parameters:\n    - numericOnly (bool): If True, only include numeric columns.\n\n    Returns:\n    - DataFrame with group keys as index and column means as values.\n    \"\"\"\n    sampleRow = next(iter(self.groups.values()))[0]\n    valueIndices = [\n        i for i in range(len(self.columns))\n        if i not in self.groupbyColumnIndices and (\n                not numeric_only or isinstance(sampleRow[i], (int, float))\n        )\n    ]\n    valueCols = [self.columns[i] for i in valueIndices]\n\n    data = []\n    for key, group in self.groups.items():\n        row = []\n        for i in valueIndices:\n            try:\n                values = [float(row[i]) for row in group]\n                meanVal = sum(values) / len(values)\n            except (ValueError, TypeError):\n                meanVal = None\n            row.append(meanVal)\n        data.append(row)\n\n    return DataFrame(data, columns=valueCols, index=JIndex(list(self.groups.keys())))\n</code></pre>"},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.sum","title":"<code>sum()</code>","text":"<p>Calculate the sum of each column in each group.</p> <p>Returns: - Dictionary with group keys as keys and lists of column sums as values.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def sum(self):\n    \"\"\"\n    Calculate the sum of each column in each group.\n\n    Returns:\n    - Dictionary with group keys as keys and lists of column sums as values.\n    \"\"\"\n    data = []\n    for key, group in self.groups.items():\n        row = [\n            sum(float(x) for x in col)\n            for i, col in enumerate(zip(*group))\n            if i not in self.groupbyColumnIndices\n        ]\n        data.append(row)\n    valueCols = [\n        col for i, col in enumerate(self.columns)\n        if i not in self.groupbyColumnIndices\n    ]\n\n    return DataFrame(data, columns=valueCols, index=JIndex(list(self.groups.keys())))\n</code></pre>"},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.count","title":"<code>count()</code>","text":"<p>Count the number of elements in each column for each group.</p> <p>Returns: - Dictionary with group keys as keys and lists of counts as values.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def count(self):\n    \"\"\"\n    Count the number of elements in each column for each group.\n\n    Returns:\n    - Dictionary with group keys as keys and lists of counts as values.\n    \"\"\"\n    data = []\n    for key, group in self.groups.items():\n        row = [\n            len(col)\n            for i, col in enumerate(zip(*group))\n            if i not in self.groupbyColumnIndices\n        ]\n        data.append(row)\n    valueCols = [\n        col for i, col in enumerate(self.columns)\n        if i not in self.groupbyColumnIndices\n    ]\n\n    return DataFrame(data, columns=valueCols, index=JIndex(list(self.groups.keys())))\n</code></pre>"},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.apply","title":"<code>apply(func)</code>","text":"<p>Apply a custom function to each column in each group.</p> <p>Parameters: - func: Function to apply to each column.</p> <p>Returns: - Dictionary with group keys as keys and lists of results as values.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def apply(self, func):\n    \"\"\"\n    Apply a custom function to each column in each group.\n\n    Parameters:\n    - func: Function to apply to each column.\n\n    Returns:\n    - Dictionary with group keys as keys and lists of results as values.\n    \"\"\"\n    data = []\n    for key, group in self.groups.items():\n        row = [\n            func(col)\n            for i, col in enumerate(zip(*group))\n            if i not in self.groupbyColumnIndices\n        ]\n        data.append(row)\n    valueCols = [\n        col for i, col in enumerate(self.columns)\n        if i not in self.groupbyColumnIndices\n    ]\n\n    return DataFrame(data, columns=valueCols, index=JIndex(list(self.groups.keys())))\n</code></pre>"},{"location":"dataframe_groupby/#Jandas.dataframe.GroupBy.getGroupKeys","title":"<code>getGroupKeys()</code>","text":"<p>Get the keys of all groups.</p> <p>Returns: - List of group keys.</p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>def getGroupKeys(self):\n    \"\"\"\n    Get the keys of all groups.\n\n    Returns:\n    - List of group keys.\n    \"\"\"\n    return list(self.groups.keys())\n</code></pre>"},{"location":"dataframe_jindex/","title":"API Reference","text":""},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex","title":"<code>Jandas.dataframe.JIndex</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>class JIndex(object):\n    def __init__(self, data, name=None):\n        self.data = list(data)\n        self.name = name\n\n    def __getitem__(self, key):\n        if isinstance(key, int):\n            return self.data[key]\n        elif isinstance(key, slice):\n            return JIndex(self.data[key])\n        elif isinstance(key, list):\n            if all(isinstance(k, bool) for k in key):\n                # Boolean mask\n                return JIndex([v for v, m in zip(self.data, key) if m])\n            else:\n                return JIndex([self.data[k] for k in key])\n        else:\n            raise TypeError(\"Invalid index type for JIndex\")\n\n    def __len__(self):\n        return len(self.data)\n\n    def __iter__(self):\n        return iter(self.data)\n\n    def __repr__(self):\n        content = ', '.join(repr(x) for x in self.data)\n        return \"JIndex([{}])\".format(content)\n\n    def __contains__(self, item):\n        # Wrap item as tuple if index values are tuples of length 1\n        if self.data and isinstance(self.data[0], tuple) and len(self.data[0]) == 1:\n            item = (item,)\n        return item in self.data\n\n    def __add__(self, other):\n        return JIndex(self.data + list(other))\n\n    def __radd__(self, other):\n        return JIndex(list(other) + self.data)\n\n    def __eq__(self, other):\n        if isinstance(other, JIndex):\n            other = other.data\n        return [a == b for a, b in zip(self.data, other)]\n\n    def __getattr__(self, name):\n        raise AttributeError(\n            \"'JIndex' object has no attribute '{}' (JIndex is immutable like pandas.Index)\".format(name))\n\n    def __setitem__(self, key, value):\n        raise TypeError(\"JIndex does not support item assignment\")\n\n    # Optional: Add slicing support that returns JIndex\n    def __getslice__(self, i, j):\n        return JIndex(self._data[i:j])\n\n    @property\n    def str(self):\n        return JStringMethods(self)\n\n    @property\n    def values(self):\n        return self.data\n\n    def to_list(self):\n        return list(self.data)\n\n    def index(self, val):\n        return self.data.index(val)\n\n    def append(self, value):\n        raise AttributeError(\"JIndex has no attribute 'append' (immutable)\")\n\n    def pop(self, index=-1):\n\n        raise AttributeError(\"JIndex has no attribute 'pop' (immutable)\")\n\n    def map(self, func):\n        return JIndex([func(v) for v in self.data])\n\n    def unique(self):\n        seen = set()\n        return JIndex([x for x in self.data if not (x in seen or seen.add(x))])\n\n    def astype(self, dtype):\n        if dtype == str:\n            return JIndex([str(x) for x in self.data], name=self.name)\n        else:\n            raise NotImplementedError(\"astype currently only supports str\")\n\n    def is_unique(self):\n        return len(set(self.data)) == len(self.data)\n\n    def duplicated(self):\n        seen = set()\n        duplicates = set()\n        return [x in seen and not (x in duplicates or duplicates.add(x)) or x in duplicates\n                for x in self.data if not seen.add(x)]\n\n    def nunique(self):\n        return len(set(self.data))\n\n    def intersection(self, other):\n        return JIndex([x for x in self.data if x in other], name=self.name)\n\n    def union(self, other):\n        return JIndex(list(dict.fromkeys(self.data + list(other))), name=self.name)\n\n    def difference(self, other):\n        return JIndex([x for x in self.data if x not in other], name=self.name)\n\n    def get_loc(self, val):\n        if val not in self.data:\n            raise KeyError(\"{} not found in JIndex\".format(val))\n        return [i for i, v in enumerate(self.data) if v == val]\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.data","title":"<code>data = list(data)</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.str","title":"<code>str</code>  <code>property</code>","text":""},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.values","title":"<code>values</code>  <code>property</code>","text":""},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__init__","title":"<code>__init__(data, name=None)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __init__(self, data, name=None):\n    self.data = list(data)\n    self.name = name\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __getitem__(self, key):\n    if isinstance(key, int):\n        return self.data[key]\n    elif isinstance(key, slice):\n        return JIndex(self.data[key])\n    elif isinstance(key, list):\n        if all(isinstance(k, bool) for k in key):\n            # Boolean mask\n            return JIndex([v for v, m in zip(self.data, key) if m])\n        else:\n            return JIndex([self.data[k] for k in key])\n    else:\n        raise TypeError(\"Invalid index type for JIndex\")\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__len__","title":"<code>__len__()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __len__(self):\n    return len(self.data)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __iter__(self):\n    return iter(self.data)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __repr__(self):\n    content = ', '.join(repr(x) for x in self.data)\n    return \"JIndex([{}])\".format(content)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__contains__","title":"<code>__contains__(item)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __contains__(self, item):\n    # Wrap item as tuple if index values are tuples of length 1\n    if self.data and isinstance(self.data[0], tuple) and len(self.data[0]) == 1:\n        item = (item,)\n    return item in self.data\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__add__","title":"<code>__add__(other)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __add__(self, other):\n    return JIndex(self.data + list(other))\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__radd__","title":"<code>__radd__(other)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __radd__(self, other):\n    return JIndex(list(other) + self.data)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __eq__(self, other):\n    if isinstance(other, JIndex):\n        other = other.data\n    return [a == b for a, b in zip(self.data, other)]\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__getattr__","title":"<code>__getattr__(name)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __getattr__(self, name):\n    raise AttributeError(\n        \"'JIndex' object has no attribute '{}' (JIndex is immutable like pandas.Index)\".format(name))\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __setitem__(self, key, value):\n    raise TypeError(\"JIndex does not support item assignment\")\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.__getslice__","title":"<code>__getslice__(i, j)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __getslice__(self, i, j):\n    return JIndex(self._data[i:j])\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.to_list","title":"<code>to_list()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def to_list(self):\n    return list(self.data)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.index","title":"<code>index(val)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def index(self, val):\n    return self.data.index(val)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.append","title":"<code>append(value)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def append(self, value):\n    raise AttributeError(\"JIndex has no attribute 'append' (immutable)\")\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.pop","title":"<code>pop(index=-1)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def pop(self, index=-1):\n\n    raise AttributeError(\"JIndex has no attribute 'pop' (immutable)\")\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.map","title":"<code>map(func)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def map(self, func):\n    return JIndex([func(v) for v in self.data])\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.unique","title":"<code>unique()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def unique(self):\n    seen = set()\n    return JIndex([x for x in self.data if not (x in seen or seen.add(x))])\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.astype","title":"<code>astype(dtype)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def astype(self, dtype):\n    if dtype == str:\n        return JIndex([str(x) for x in self.data], name=self.name)\n    else:\n        raise NotImplementedError(\"astype currently only supports str\")\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.is_unique","title":"<code>is_unique()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def is_unique(self):\n    return len(set(self.data)) == len(self.data)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.duplicated","title":"<code>duplicated()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def duplicated(self):\n    seen = set()\n    duplicates = set()\n    return [x in seen and not (x in duplicates or duplicates.add(x)) or x in duplicates\n            for x in self.data if not seen.add(x)]\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.nunique","title":"<code>nunique()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def nunique(self):\n    return len(set(self.data))\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.intersection","title":"<code>intersection(other)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def intersection(self, other):\n    return JIndex([x for x in self.data if x in other], name=self.name)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.union","title":"<code>union(other)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def union(self, other):\n    return JIndex(list(dict.fromkeys(self.data + list(other))), name=self.name)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.difference","title":"<code>difference(other)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def difference(self, other):\n    return JIndex([x for x in self.data if x not in other], name=self.name)\n</code></pre>"},{"location":"dataframe_jindex/#Jandas.dataframe.JIndex.get_loc","title":"<code>get_loc(val)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def get_loc(self, val):\n    if val not in self.data:\n        raise KeyError(\"{} not found in JIndex\".format(val))\n    return [i for i, v in enumerate(self.data) if v == val]\n</code></pre>"},{"location":"dataframe_jstringmethods/","title":"API Reference","text":""},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods","title":"<code>Jandas.dataframe.JStringMethods</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>Jandas\\dataframe.py</code> <pre><code>class JStringMethods(object):\n    def __init__(self, index):\n        self.index = index  # JIndex object\n        self.data = index.data\n\n    def _apply(self, func):\n        return JIndex([func(val) for val in self.data])\n\n    def contains(self, pat):\n        return [pat in val for val in self.data]\n\n    def startswith(self, prefix):\n        return [val.startswith(prefix) for val in self.data]\n\n    def endswith(self, suffix):\n        return [val.endswith(suffix) for val in self.data]\n\n    def upper(self):\n        return self._apply(lambda x: x.upper())\n\n    def lower(self):\n        return self._apply(lambda x: x.lower())\n\n    def replace(self, old, new):\n        return self._apply(lambda x: x.replace(old, new))\n\n    def strip(self):\n        return self._apply(lambda x: x.strip())\n\n    def match(self, regex):\n        import re\n        pattern = re.compile(regex)\n        return [bool(pattern.match(val)) for val in self.data]\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.index","title":"<code>index = index</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.data","title":"<code>data = index.data</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.__init__","title":"<code>__init__(index)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __init__(self, index):\n    self.index = index  # JIndex object\n    self.data = index.data\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.contains","title":"<code>contains(pat)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def contains(self, pat):\n    return [pat in val for val in self.data]\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.startswith","title":"<code>startswith(prefix)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def startswith(self, prefix):\n    return [val.startswith(prefix) for val in self.data]\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.endswith","title":"<code>endswith(suffix)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def endswith(self, suffix):\n    return [val.endswith(suffix) for val in self.data]\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.upper","title":"<code>upper()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def upper(self):\n    return self._apply(lambda x: x.upper())\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.lower","title":"<code>lower()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def lower(self):\n    return self._apply(lambda x: x.lower())\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.replace","title":"<code>replace(old, new)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def replace(self, old, new):\n    return self._apply(lambda x: x.replace(old, new))\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.strip","title":"<code>strip()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def strip(self):\n    return self._apply(lambda x: x.strip())\n</code></pre>"},{"location":"dataframe_jstringmethods/#Jandas.dataframe.JStringMethods.match","title":"<code>match(regex)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def match(self, regex):\n    import re\n    pattern = re.compile(regex)\n    return [bool(pattern.match(val)) for val in self.data]\n</code></pre>"},{"location":"dataframe_rolling/","title":"API Reference","text":""},{"location":"dataframe_rolling/#Jandas.dataframe.Rolling","title":"<code>Jandas.dataframe.Rolling</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>class Rolling:\n    def __init__(self, obj, window, min_periods=None):\n        self.obj = obj\n        self.window = window\n        self.min_periods = window if min_periods is None else min_periods\n\n    def mean(self):\n        if isinstance(self.obj, DataFrame):\n            return self._mean_dataframe()\n        elif isinstance(self.obj, Series):\n            return self._mean_series()\n        else:\n            raise TypeError(\"Rolling object must be a DataFrame or Series\")\n\n    def _mean_series(self):\n        values = self.obj.data\n        index = self.obj.index\n        result = []\n\n        # Clean and convert to float\n        cleanValues = []\n        for val in values:\n            try:\n                val = str(val).replace(',', '')\n                cleanValues.append(float(val))\n            except Exception:\n                cleanValues.append(None)\n\n        for i in range(len(cleanValues)):\n            windowVals = cleanValues[max(0, i - self.window + 1):i + 1]\n            validVals = [v for v in windowVals if v is not None]\n\n            if len(validVals) &gt;= self.min_periods:\n                avg = sum(validVals) / len(validVals)\n            else:\n                avg = None\n\n            result.append(avg)\n\n        return Series(result, self.obj.name, index)\n\n    def _mean_dataframe(self):\n        resultRows = []\n        numRows = len(self.obj.data)\n        rollingData = {col: [] for col in self.obj.columns}\n\n        for col in self.obj.columns:\n            colValues = self.obj[col]\n            cleanValues = []\n            for val in colValues:\n                try:\n                    val = str(val).replace(',', '')\n                    cleanValues.append(float(val))\n                except Exception:\n                    cleanValues.append(None)\n\n            for i in range(numRows):\n                windowVals = cleanValues[max(0, i - self.window + 1):i + 1]\n                validVals = [v for v in windowVals if v is not None]\n\n                if len(validVals) &gt;= self.min_periods:\n                    avg = sum(validVals) / len(validVals)\n                else:\n                    avg = None\n\n                rollingData[col].append(avg)\n\n        for i in range(numRows):\n            rowValues = [rollingData[col][i] for col in self.obj.columns]\n            resultRows.append(Vector(rowValues, self.obj.columns))\n\n        return DataFrame(resultRows, list(self.obj.columns), self.obj.index)\n\n    def __repr__(self):\n        return \"&lt;Rolling window={}, min_periods={}&gt;\".format(self.window, self.min_periods)\n</code></pre>"},{"location":"dataframe_rolling/#Jandas.dataframe.Rolling.obj","title":"<code>obj = obj</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_rolling/#Jandas.dataframe.Rolling.window","title":"<code>window = window</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_rolling/#Jandas.dataframe.Rolling.min_periods","title":"<code>min_periods = window if min_periods is None else min_periods</code>  <code>instance-attribute</code>","text":""},{"location":"dataframe_rolling/#Jandas.dataframe.Rolling.__init__","title":"<code>__init__(obj, window, min_periods=None)</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __init__(self, obj, window, min_periods=None):\n    self.obj = obj\n    self.window = window\n    self.min_periods = window if min_periods is None else min_periods\n</code></pre>"},{"location":"dataframe_rolling/#Jandas.dataframe.Rolling.mean","title":"<code>mean()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def mean(self):\n    if isinstance(self.obj, DataFrame):\n        return self._mean_dataframe()\n    elif isinstance(self.obj, Series):\n        return self._mean_series()\n    else:\n        raise TypeError(\"Rolling object must be a DataFrame or Series\")\n</code></pre>"},{"location":"dataframe_rolling/#Jandas.dataframe.Rolling.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>Jandas\\dataframe.py</code> <pre><code>def __repr__(self):\n    return \"&lt;Rolling window={}, min_periods={}&gt;\".format(self.window, self.min_periods)\n</code></pre>"},{"location":"home/","title":"Jandas: Pandas-Like DataFrames in Ignition","text":"<p>Welcome to Jandas, a lightweight Python library designed to bring familiar <code>pandas</code>-style data manipulation to the Ignition platform.</p> <p>Jandas provides a simple, intuitive interface for working with tabular data in environments where the full power of <code>pandas</code> isn\u2019t available \u2014 such as Jython scripting in Ignition. If you've ever wished for <code>.groupby()</code>, <code>.rolling()</code>, or <code>.loc[]</code> support while working inside your Ignition gateway or Perspective scripts, Jandas aims to give you just that.</p>"},{"location":"home/#what-jandas-is","title":"What Jandas Is","text":"<ul> <li>A minimal re-implementation of core <code>pandas</code> features, tailored for environments like Ignition where the real <code>pandas</code> cannot run.</li> <li>Designed to work with Python objects like lists and dictionaries, common in Ignition datasets.</li> <li>Offers a familiar interface with classes like <code>DataFrame</code>, <code>Series</code>, and <code>GroupBy</code>.</li> </ul>"},{"location":"home/#limitations","title":"Limitations","text":"<ul> <li>Jandas is written in pure Python, not C or NumPy \u2014 which means it does not match the performance of <code>pandas</code>, especially for large datasets.</li> <li>It is focused on developer convenience and readability, not computational efficiency.</li> <li>Some advanced features of <code>pandas</code> (e.g. time series indexing, multi-indexing, broadcasting, custom dtypes) are not fully implemented.</li> <li>This project is still under active development \u2014 interfaces, behavior, and performance may change over time.</li> </ul>"},{"location":"home/#when-to-use-jandas","title":"When to Use Jandas","text":"<ul> <li>You're working inside Ignition or another Jython environment without access to <code>pandas</code>.</li> <li>You want to write clear, expressive, and testable data logic that resembles modern Python data workflows.</li> <li>You\u2019re operating on moderate-sized datasets where performance isn\u2019t the top concern.</li> </ul>"},{"location":"home/#when-not-to-use-jandas","title":"When Not to Use Jandas","text":"<ul> <li>You need high-performance data manipulation (use native <code>pandas</code> in a proper Python runtime instead).</li> <li>Your dataset contains millions of rows and complex statistical transformations.</li> <li>You require third-party integration with the broader Python data science ecosystem.</li> </ul>"},{"location":"home/#project-status","title":"Project Status","text":"<p>Jandas is alpha-stage software. While the core functionality is usable, the API may change, and performance optimizations are ongoing.</p> <p>You are welcome to use it, experiment with it, and contribute ideas or code \u2014 but be prepared for occasional sharp edges!</p>"},{"location":"home/#next-steps","title":"Next Steps","text":"<ul> <li>DataFrame</li> <li>JIndex</li> <li>GroupBy</li> <li>Rolling</li> </ul> <p>For Ignition users and curious developers alike, we hope Jandas helps bridge the gap between industrial scripting and modern data analysis.</p>"},{"location":"indexers_ilocindexer/","title":"API Reference","text":""},{"location":"indexers_ilocindexer/#Jandas.indexers._IlocIndexer","title":"<code>Jandas.indexers._IlocIndexer</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>class _IlocIndexer:\n    def __init__(self, dataframe):\n        self.dataframe = dataframe\n\n    def __getitem__(self, key):\n        if isinstance(key, tuple):\n            rowSelector, colSelector = key\n        else:\n            # If it's a single index, assume it's for rows (or columns)\n            rowSelector = key\n            colSelector = slice(None)  # Assuming we're selecting all columns in this case\n\n        # Handle single row\n        if isinstance(rowSelector, int):\n            row = self.dataframe.data[rowSelector]\n\n            if isinstance(colSelector, int):\n                return row[colSelector]\n\n            elif isinstance(colSelector, slice):\n                data = row[colSelector]\n                cols = self.dataframe.columns[colSelector]\n                return Series(data=data, index=cols, name=rowSelector)\n\n            elif isinstance(colSelector, list):\n                data = [row[i] for i in colSelector]\n                cols = [self.dataframe.columns[i] for i in colSelector]\n                return Series(data=data, index=cols, name=rowSelector)\n\n            else:\n                raise ValueError(\"Invalid column selector in .iloc[].\")\n\n        # Handle multiple rows\n        elif isinstance(rowSelector, slice):\n            selectedRows = self.dataframe.data[rowSelector]\n\n            if isinstance(colSelector, int):\n                return [row[colSelector] for row in selectedRows]\n\n            elif isinstance(colSelector, slice):\n                newData = [row[colSelector] for row in selectedRows]\n                newColumns = self.dataframe.columns[colSelector]\n                return Jandas.DataFrame(newData, columns=newColumns)\n\n            elif isinstance(colSelector, list):\n                return [[row[i] for i in colSelector] for row in selectedRows]\n\n            else:\n                raise ValueError(\"Invalid column selector in .iloc[].\")\n\n        else:\n            raise ValueError(\"Row selector must be int or slice.\")\n\n    def __setitem__(self, key, value):\n        self.dataframe.set_item_by_iloc(key, value)\n</code></pre>"},{"location":"indexers_ilocindexer/#Jandas.indexers._IlocIndexer.dataframe","title":"<code>dataframe = dataframe</code>  <code>instance-attribute</code>","text":""},{"location":"indexers_ilocindexer/#Jandas.indexers._IlocIndexer.__init__","title":"<code>__init__(dataframe)</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __init__(self, dataframe):\n    self.dataframe = dataframe\n</code></pre>"},{"location":"indexers_ilocindexer/#Jandas.indexers._IlocIndexer.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __getitem__(self, key):\n    if isinstance(key, tuple):\n        rowSelector, colSelector = key\n    else:\n        # If it's a single index, assume it's for rows (or columns)\n        rowSelector = key\n        colSelector = slice(None)  # Assuming we're selecting all columns in this case\n\n    # Handle single row\n    if isinstance(rowSelector, int):\n        row = self.dataframe.data[rowSelector]\n\n        if isinstance(colSelector, int):\n            return row[colSelector]\n\n        elif isinstance(colSelector, slice):\n            data = row[colSelector]\n            cols = self.dataframe.columns[colSelector]\n            return Series(data=data, index=cols, name=rowSelector)\n\n        elif isinstance(colSelector, list):\n            data = [row[i] for i in colSelector]\n            cols = [self.dataframe.columns[i] for i in colSelector]\n            return Series(data=data, index=cols, name=rowSelector)\n\n        else:\n            raise ValueError(\"Invalid column selector in .iloc[].\")\n\n    # Handle multiple rows\n    elif isinstance(rowSelector, slice):\n        selectedRows = self.dataframe.data[rowSelector]\n\n        if isinstance(colSelector, int):\n            return [row[colSelector] for row in selectedRows]\n\n        elif isinstance(colSelector, slice):\n            newData = [row[colSelector] for row in selectedRows]\n            newColumns = self.dataframe.columns[colSelector]\n            return Jandas.DataFrame(newData, columns=newColumns)\n\n        elif isinstance(colSelector, list):\n            return [[row[i] for i in colSelector] for row in selectedRows]\n\n        else:\n            raise ValueError(\"Invalid column selector in .iloc[].\")\n\n    else:\n        raise ValueError(\"Row selector must be int or slice.\")\n</code></pre>"},{"location":"indexers_ilocindexer/#Jandas.indexers._IlocIndexer.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __setitem__(self, key, value):\n    self.dataframe.set_item_by_iloc(key, value)\n</code></pre>"},{"location":"indexers_locindexer/","title":"API Reference","text":""},{"location":"indexers_locindexer/#Jandas.indexers._LocIndexer","title":"<code>Jandas.indexers._LocIndexer</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>class _LocIndexer:\n    def __init__(self, dataframe, vectorCls=None, dataframeCls=None):\n        self.dataframe = dataframe\n        self.Vector = vectorCls\n        self.DataFrame = dataframeCls\n\n    def __getitem__(self, key):\n        if isinstance(key, tuple):\n            rowSelector, colSelector = key\n        else:\n            rowSelector = key\n            colSelector = slice(None)\n        print(self.dataframe.index)\n        print(rowSelector in self.dataframe.index)\n        # --- ROW SELECTION ---\n        if isinstance(rowSelector, slice):\n            selectedRows = self.dataframe.data[rowSelector]\n        elif rowSelector in self.dataframe.index:\n            return self.dataframe.rowByLabel(key)\n        elif isinstance(rowSelector, int):\n            row = self.dataframe.data[rowSelector]\n\n            # --- COLUMN SELECTION FOR SINGLE ROW ---\n            colSelector = self._resolve_col_selector(colSelector)\n            if isinstance(colSelector, list):\n                return [row[idx] for idx in colSelector]\n            elif isinstance(colSelector, int):\n                return row[colSelector]\n\n            else:\n                raise ValueError(\"Invalid column selector for single row.\")\n        else:\n            raise ValueError(\"Row selector must be an int or slice.\")\n\n        # --- COLUMN SELECTION FOR MULTIPLE ROWS ---\n        colSelector = self._resolve_col_selector(colSelector)\n\n        if isinstance(colSelector, list):\n            dfNew = self.DataFrame([[row[idx] for idx in colSelector] for row in selectedRows],\n                                   [self.dataframe.columns[idx] for idx in colSelector])\n            dfNew._index = self.dataframe.index\n            return dfNew\n        elif isinstance(colSelector, int):\n            return [row[colSelector] for row in selectedRows]\n        else:\n            return selectedRows  # All columns\n\n    def __setitem__(self, key, value):\n        self.dataframe.set_item_by_loc(key, value)\n\n    def _resolve_col_selector(self, colSelector):\n        # Normalize the column selector to a list of column indices\n        columns = self.dataframe.columns\n\n        if isinstance(colSelector, str):\n            return columns.index(colSelector)\n        elif isinstance(colSelector, list):\n            # Handle boolean masks\n            if all(isinstance(c, bool) for c in colSelector):\n                if len(colSelector) != len(columns):\n                    raise ValueError(\"Boolean mask length must match number of columns.\")\n                return [i for i, flag in enumerate(colSelector) if flag]\n            else:\n                return [columns.index(col) for col in colSelector]\n        elif isinstance(colSelector, slice):\n            return list(range(*colSelector.indices(len(columns))))\n        elif colSelector == slice(None):\n            return list(range(len(columns)))\n        else:\n            raise ValueError(\"Unsupported column selector\")\n</code></pre>"},{"location":"indexers_locindexer/#Jandas.indexers._LocIndexer.dataframe","title":"<code>dataframe = dataframe</code>  <code>instance-attribute</code>","text":""},{"location":"indexers_locindexer/#Jandas.indexers._LocIndexer.Vector","title":"<code>Vector = vectorCls</code>  <code>instance-attribute</code>","text":""},{"location":"indexers_locindexer/#Jandas.indexers._LocIndexer.DataFrame","title":"<code>DataFrame = dataframeCls</code>  <code>instance-attribute</code>","text":""},{"location":"indexers_locindexer/#Jandas.indexers._LocIndexer.__init__","title":"<code>__init__(dataframe, vectorCls=None, dataframeCls=None)</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __init__(self, dataframe, vectorCls=None, dataframeCls=None):\n    self.dataframe = dataframe\n    self.Vector = vectorCls\n    self.DataFrame = dataframeCls\n</code></pre>"},{"location":"indexers_locindexer/#Jandas.indexers._LocIndexer.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __getitem__(self, key):\n    if isinstance(key, tuple):\n        rowSelector, colSelector = key\n    else:\n        rowSelector = key\n        colSelector = slice(None)\n    print(self.dataframe.index)\n    print(rowSelector in self.dataframe.index)\n    # --- ROW SELECTION ---\n    if isinstance(rowSelector, slice):\n        selectedRows = self.dataframe.data[rowSelector]\n    elif rowSelector in self.dataframe.index:\n        return self.dataframe.rowByLabel(key)\n    elif isinstance(rowSelector, int):\n        row = self.dataframe.data[rowSelector]\n\n        # --- COLUMN SELECTION FOR SINGLE ROW ---\n        colSelector = self._resolve_col_selector(colSelector)\n        if isinstance(colSelector, list):\n            return [row[idx] for idx in colSelector]\n        elif isinstance(colSelector, int):\n            return row[colSelector]\n\n        else:\n            raise ValueError(\"Invalid column selector for single row.\")\n    else:\n        raise ValueError(\"Row selector must be an int or slice.\")\n\n    # --- COLUMN SELECTION FOR MULTIPLE ROWS ---\n    colSelector = self._resolve_col_selector(colSelector)\n\n    if isinstance(colSelector, list):\n        dfNew = self.DataFrame([[row[idx] for idx in colSelector] for row in selectedRows],\n                               [self.dataframe.columns[idx] for idx in colSelector])\n        dfNew._index = self.dataframe.index\n        return dfNew\n    elif isinstance(colSelector, int):\n        return [row[colSelector] for row in selectedRows]\n    else:\n        return selectedRows  # All columns\n</code></pre>"},{"location":"indexers_locindexer/#Jandas.indexers._LocIndexer.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __setitem__(self, key, value):\n    self.dataframe.set_item_by_loc(key, value)\n</code></pre>"},{"location":"indexers_multiindex/","title":"API Reference","text":""},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex","title":"<code>Jandas.indexers.MultiIndex</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>class MultiIndex:\n    def __init__(self, keys):\n        # Normalize keys\n        if not keys:\n            self.keys = []\n            self.nlevels = 0\n        elif isinstance(keys[0], tuple):\n            self.keys = keys\n            self.nlevels = len(keys[0])\n        else:\n            # Single-level index, wrap each item in a tuple\n            self.keys = [(k,) for k in keys]\n            self.nlevels = 1\n\n        self.levels = self._compute_levels()\n        self.codes = self._compute_codes()\n\n    def _compute_levels(self):\n        levels = []\n        for i in range(self.nlevels):\n            level_i = sorted(set(k[i] for k in self.keys))\n            levels.append(level_i)\n        return levels\n\n    def _compute_codes(self):\n        codes = []\n        for k in self.keys:\n            codes.append([self.levels[i].index(k[i]) for i in range(self.nlevels)])\n        return codes\n\n    def __getitem__(self, idx):\n        if self.nlevels == 1:\n            # Return scalar for single-level index\n            return self.keys[idx][0]\n        return self.keys[idx]\n\n    def __len__(self):\n        return len(self.keys)\n\n    def __repr__(self):\n        header = \"MultiIndex with {} entries and {} level{}\\n\".format(len(self), self.nlevels,\n                                                                      's' if self.nlevels &gt; 1 else '')\n        preview = \"\\n\".join(str(self[i]) for i in range(min(10, len(self))))\n        return header + preview + (\"\\n...\" if len(self.keys) &gt; 10 else \"\")\n</code></pre>"},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex.keys","title":"<code>keys = []</code>  <code>instance-attribute</code>","text":""},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex.nlevels","title":"<code>nlevels = 0</code>  <code>instance-attribute</code>","text":""},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex.levels","title":"<code>levels = self._compute_levels()</code>  <code>instance-attribute</code>","text":""},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex.codes","title":"<code>codes = self._compute_codes()</code>  <code>instance-attribute</code>","text":""},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex.__init__","title":"<code>__init__(keys)</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __init__(self, keys):\n    # Normalize keys\n    if not keys:\n        self.keys = []\n        self.nlevels = 0\n    elif isinstance(keys[0], tuple):\n        self.keys = keys\n        self.nlevels = len(keys[0])\n    else:\n        # Single-level index, wrap each item in a tuple\n        self.keys = [(k,) for k in keys]\n        self.nlevels = 1\n\n    self.levels = self._compute_levels()\n    self.codes = self._compute_codes()\n</code></pre>"},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex.__getitem__","title":"<code>__getitem__(idx)</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __getitem__(self, idx):\n    if self.nlevels == 1:\n        # Return scalar for single-level index\n        return self.keys[idx][0]\n    return self.keys[idx]\n</code></pre>"},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex.__len__","title":"<code>__len__()</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __len__(self):\n    return len(self.keys)\n</code></pre>"},{"location":"indexers_multiindex/#Jandas.indexers.MultiIndex.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>Jandas\\indexers.py</code> <pre><code>def __repr__(self):\n    header = \"MultiIndex with {} entries and {} level{}\\n\".format(len(self), self.nlevels,\n                                                                  's' if self.nlevels &gt; 1 else '')\n    preview = \"\\n\".join(str(self[i]) for i in range(min(10, len(self))))\n    return header + preview + (\"\\n...\" if len(self.keys) &gt; 10 else \"\")\n</code></pre>"},{"location":"jandas/","title":"API Reference","text":""},{"location":"jandas/#Jandas","title":"<code>Jandas</code>","text":""},{"location":"jandas/#Jandas.read_csv","title":"<code>read_csv(file_path)</code>","text":"<p>Read a CSV file and return a DataFrame object.</p> <p>Parameters: - file_path (str): The path to the CSV file to read.</p> <p>Returns: - DataFrame: A DataFrame containing the data from the CSV file with column names.</p> <p>Notes: - Automatically attempts to convert numeric values to int or float. - If conversion fails, the value is left as a string.</p> Source code in <code>Jandas\\__init__.py</code> <pre><code>def read_csv(file_path: str) -&gt; pandas.DataFrame:\n    \"\"\"\n    Read a CSV file and return a DataFrame object.\n\n    Parameters:\n    - file_path (str): The path to the CSV file to read.\n\n    Returns:\n    - DataFrame: A DataFrame containing the data from the CSV file with column names.\n\n    Notes:\n    - Automatically attempts to convert numeric values to int or float.\n    - If conversion fails, the value is left as a string.\n    \"\"\"\n    with open(file_path, 'r') as f:\n        reader = csv.reader(f)\n        # Try to read the first row (header)\n        try:\n            columns = next(reader)\n        except StopIteration:\n            # If the file is empty, return an empty DataFrame\n            return DataFrame([], [])\n\n        # If the header is empty, also return an empty DataFrame\n        if not columns:\n            return DataFrame([], [])\n        data = []\n        for row in reader:\n            # Automatic type conversion\n            parsedRow = []\n            for value in row:\n                try:\n                    # Convert to float if possible\n                    parsedValue = float(value)\n                    if parsedValue.is_integer():\n                        parsedValue = int(parsedValue)\n                except ValueError:\n                    # Leave as string if conversion fails\n                    parsedValue = value\n                parsedRow.append(parsedValue)\n            data.append(parsedRow)\n        return DataFrame(data, columns)\n</code></pre>"},{"location":"jandas/#Jandas.merge","title":"<code>merge(left, right, how='inner', left_on=None, right_on=None, left_index=False, right_index=False)</code>","text":"<p>Merge two DataFrames based on indices or specific columns.</p> <p>Parameters: - left (DataFrame): The left DataFrame to merge. - right (DataFrame): The right DataFrame to merge. - how (str): Type of merge to perform. Options: 'inner', 'outer', 'left', 'right'. Default is 'inner'. - left_on (str): Column name in the left DataFrame to join on (required if <code>left_index</code> is False). - right_on (str): Column name in the right DataFrame to join on (required if <code>right_index</code> is False). - left_index (bool): If True, use the index from the left DataFrame as the join key. Default is False. - right_index (bool): If True, use the index from the right DataFrame as the join key. Default is False.</p> <p>Returns: - DataFrame: A new DataFrame containing the merged data.</p> <p>Raises: - ValueError: If <code>how</code> is not a valid merge type.</p> Source code in <code>Jandas\\__init__.py</code> <pre><code>def merge(left, right, how='inner', left_on=None, right_on=None, left_index=False, right_index=False):\n    \"\"\"\n    Merge two DataFrames based on indices or specific columns.\n\n    Parameters:\n    - left (DataFrame): The left DataFrame to merge.\n    - right (DataFrame): The right DataFrame to merge.\n    - how (str): Type of merge to perform. Options: 'inner', 'outer', 'left', 'right'. Default is 'inner'.\n    - left_on (str): Column name in the left DataFrame to join on (required if `left_index` is False).\n    - right_on (str): Column name in the right DataFrame to join on (required if `right_index` is False).\n    - left_index (bool): If True, use the index from the left DataFrame as the join key. Default is False.\n    - right_index (bool): If True, use the index from the right DataFrame as the join key. Default is False.\n\n    Returns:\n    - DataFrame: A new DataFrame containing the merged data.\n\n    Raises:\n    - ValueError: If `how` is not a valid merge type.\n    \"\"\"\n    if left_index:\n        leftKeys = left.index\n    else:\n        leftKeys = [row[left.columns.index(left_on)] for row in left.data]\n\n    if right_index:\n        rightKeys = right.index\n    else:\n        rightKeys = [row[right.columns.index(right_on)] for row in right.data]\n\n    mergedData = []\n    mergedColumns = left.columns + [col for col in right.columns if col not in left.columns]\n\n    if how == 'inner':\n        commonKeys = set(leftKeys).intersection(rightKeys)\n    elif how == 'outer':\n        commonKeys = set(leftKeys).union(rightKeys)\n    elif how == 'left':\n        commonKeys = set(leftKeys)\n    elif how == 'right':\n        commonKeys = set(rightKeys)\n    else:\n        raise ValueError(\"Invalid `how` value\")\n\n    for key in commonKeys:\n        leftRows = [row for row, k in zip(left.data, leftKeys) if k == key]\n        rightRows = [row for row, k in zip(right.data, rightKeys) if k == key]\n\n        if not leftRows:\n            leftRows = [Vector([None] * len(left.columns))]\n        if not rightRows:\n            rightRows = [Vector([None] * len(right.columns))]\n\n        for lRow in leftRows:\n            for rRow in rightRows:\n                mergedRow = list(lRow) + [r for r, col in zip(rRow, right.columns) if col not in left.columns]\n                mergedData.append(mergedRow)\n\n    return DataFrame(data=mergedData, columns=mergedColumns)\n</code></pre>"},{"location":"jandas/#Jandas.concat","title":"<code>concat(dfs, axis=0)</code>","text":"<p>Concatenate multiple DataFrames along a specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>dfs</code> <code>list</code> <p>List of DataFrames to concatenate.</p> required <code>axis</code> <code>int</code> <p>The axis along which to concatenate (0 for rows, 1 for columns).</p> <code>0</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>The concatenated DataFrame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the axis is invalid or the DataFrames are incompatible.</p> Source code in <code>Jandas\\__init__.py</code> <pre><code>def concat(dfs, axis=0):\n    \"\"\"\n    Concatenate multiple DataFrames along a specified axis.\n\n    Args:\n        dfs (list): List of DataFrames to concatenate.\n        axis (int): The axis along which to concatenate (0 for rows, 1 for columns).\n\n    Returns:\n        DataFrame: The concatenated DataFrame.\n\n    Raises:\n        ValueError: If the axis is invalid or the DataFrames are incompatible.\n    \"\"\"\n    if not dfs:\n        raise ValueError(\"No DataFrames to concatenate\")\n\n    if axis not in (0, 1):\n        raise ValueError(\"Invalid axis value. Axis must be 0 or 1.\")\n\n    # Validate all are DataFrames and have consistent columns/rows as needed\n    if axis == 0:\n        # Vertical concat: columns must be the same (or compatible)\n        baseColumns = dfs[0].columns\n        for df in dfs[1:]:\n            if df.columns != baseColumns:\n                raise ValueError(\"All DataFrames must have the same columns to concatenate along axis 0\")\n        # Combine all data rows\n        combinedData = []\n        for df in dfs:\n            combinedData.extend(df.data)\n        return DataFrame(combinedData, dfs[0].columns)\n\n    else:  # axis == 1, horizontal concat: number of rows must be equal\n        baseLen = len(dfs[0].data)\n        for df in dfs[1:]:\n            if len(df.data) != baseLen:\n                raise ValueError(\"All DataFrames must have the same number of rows to concatenate along axis 1\")\n        concatenatedData = []\n        for rows in zip(*(df.data for df in dfs)):\n            newRow = []\n            for row in rows:\n                newRow.extend(row)\n            concatenatedData.append(newRow)\n        # Combine columns from all dfs\n        combinedColumns = dataframe.JIndex([])\n        for df in dfs:\n            combinedColumns += df.columns\n        return DataFrame(concatenatedData, combinedColumns)\n</code></pre>"},{"location":"jandas/#Jandas.to_numeric","title":"<code>to_numeric(val, errors='raise')</code>","text":"<p>Convert a value or a Series of values to float or int.</p> <p>If given a Series, return a Series of numeric values. If given a scalar, return a single numeric value.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>Series | str | float | int</code> <p>Input value(s).</p> required <code>errors</code> <code>str</code> <p>'raise' or 'coerce'.</p> <code>'raise'</code> <p>Returns:</p> Type Description <p>Series or float or int: Converted numeric value(s).</p> Source code in <code>Jandas\\__init__.py</code> <pre><code>def to_numeric(val, errors='raise'):\n    \"\"\"\n    Convert a value or a Series of values to float or int.\n\n    If given a Series, return a Series of numeric values.\n    If given a scalar, return a single numeric value.\n\n    Args:\n        val (Series | str | float | int): Input value(s).\n        errors (str): 'raise' or 'coerce'.\n\n    Returns:\n        Series or float or int: Converted numeric value(s).\n    \"\"\"\n\n    def convert(v):\n        try:\n            return float(v) if '.' in str(v) else int(v)\n        except Exception:\n            if errors == 'coerce':\n                return None\n            else:\n                raise ValueError(\"Cannot convert value: {}\".format(v))\n\n    if isinstance(val, Series):\n        return Series([convert(v) for v in val.data])\n    else:\n        return convert(val)\n</code></pre>"},{"location":"jandas/#Jandas.arrange","title":"<code>arrange(start, stop=None, step=1)</code>","text":"<p>Mimics numpy.arange() using pure Python.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>Start value, or stop if stop is None.</p> required <code>stop</code> <code>int</code> <p>Stop value (non-inclusive).</p> <code>None</code> <code>step</code> <code>int</code> <p>Step size.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of numbers from start to stop (exclusive) by step.</p> Source code in <code>Jandas\\__init__.py</code> <pre><code>def arrange(start, stop=None, step=1):\n    \"\"\"\n    Mimics numpy.arange() using pure Python.\n\n    Args:\n        start (int): Start value, or stop if stop is None.\n        stop (int, optional): Stop value (non-inclusive).\n        step (int, optional): Step size.\n\n    Returns:\n        list: A list of numbers from start to stop (exclusive) by step.\n    \"\"\"\n    if stop is None:\n        start, stop = 0, start\n\n    if step == 0:\n        raise ValueError(\"step must not be zero\")\n\n    result = []\n    i = start\n    if step &gt; 0:\n        while i &lt; stop:\n            result.append(i)\n            i += step\n    else:\n        while i &gt; stop:\n            result.append(i)\n            i += step\n    return result\n</code></pre>"},{"location":"jandas/#Jandas.to_datetime","title":"<code>to_datetime(obj, fmt=None, errors='raise', default_year=None)</code>","text":"<p>Convert a string or Series of strings to datetime objects with support for multiple formats.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str | Series</code> <p>A datetime string or a Series of strings.</p> required <code>fmt</code> <code>str | list | None</code> <p>A format string, list of formats, or None to try common formats.</p> <code>None</code> <code>errors</code> <code>str</code> <p>'raise' or 'coerce'.</p> <code>'raise'</code> <code>default_year</code> <code>int or None</code> <p>If a date has no year (e.g., \"March 3\"), use this year.</p> <code>None</code> <p>Returns:</p> Type Description <p>datetime.datetime or Series: Parsed datetime(s)</p> Source code in <code>Jandas\\__init__.py</code> <pre><code>def to_datetime(obj, fmt=None, errors=\"raise\", default_year=None):\n    \"\"\"\n    Convert a string or Series of strings to datetime objects with support for multiple formats.\n\n    Args:\n        obj (str | Series): A datetime string or a Series of strings.\n        fmt (str | list | None): A format string, list of formats, or None to try common formats.\n        errors (str): 'raise' or 'coerce'.\n        default_year (int or None): If a date has no year (e.g., \"March 3\"), use this year.\n\n    Returns:\n        datetime.datetime or Series: Parsed datetime(s)\n    \"\"\"\n    defaultFormats = [\n        \"%Y/%m/%d\",  # 2024/01/01\n        \"%Y-%m-%d\",  # 2024-01-01\n        \"%d-%m-%Y\",  # 01-02-2024\n        \"%m-%d-%Y\",  # 01-02-2024 (ambiguous)\n        \"%B %d\",  # March 3\n        \"%b %d\",  # Mar 3\n        \"%Y-%m-%d %H:%M:%S\",\n        \"%Y.%m.%d\",\n    ]\n\n    if fmt is None:\n        formats = defaultFormats\n    elif isinstance(fmt, str):\n        formats = [fmt]\n    elif isinstance(fmt, list):\n        formats = fmt\n    else:\n        raise TypeError(\"fmt must be a string, list of strings, or None\")\n\n    def parse(val):\n        val = val.strip()\n        for f in formats:\n            try:\n                parsed = datetime.datetime.strptime(val, f)\n                # If the format didn\u2019t include a year, inject it\n                if \"%Y\" not in f and default_year is not None:\n                    parsed = parsed.replace(year=default_year)\n                return parsed\n            except Exception:\n                continue\n        if errors == \"coerce\":\n            return None\n        else:\n            raise ValueError(\"Cannot parse value to datetime: '{}'\".format(val))\n\n    if isinstance(obj, Series):\n        return Series([parse(x) for x in obj.data])\n    else:\n        return parse(obj)\n</code></pre>"},{"location":"jandas/#Jandas.from_dataset","title":"<code>from_dataset(dataset)</code>","text":"<p>Convert an Ignition Dataset to a Jandas DataFrame.</p> <p>Parameters: - dataset (Dataset): Ignition Dataset object.</p> <p>Returns: - DataFrame: Jandas DataFrame with the same data and column names.</p> Source code in <code>Jandas\\__init__.py</code> <pre><code>def from_dataset(dataset):\n    \"\"\"\n    Convert an Ignition Dataset to a Jandas DataFrame.\n\n    Parameters:\n    - dataset (Dataset): Ignition Dataset object.\n\n    Returns:\n    - DataFrame: Jandas DataFrame with the same data and column names.\n    \"\"\"\n    if system is None:\n        raise RuntimeError(\"from_dataset requires Ignition's system module.\")\n\n    columnNames = list(dataset.getColumnNames())\n    data = []\n\n    for rowIndex in range(dataset.getRowCount()):\n        row = []\n        for col in columnNames:\n            row.append(dataset.getValueAt(rowIndex, col))\n        data.append(row)\n\n    return DataFrame(data=data, columns=columnNames)\n</code></pre>"},{"location":"jandas/#Jandas.to_dataset","title":"<code>to_dataset(df)</code>","text":"<p>Convert a Jandas DataFrame to an Ignition Dataset.</p> <p>Parameters: - df (DataFrame): Jandas DataFrame to convert.</p> <p>Returns: - Dataset: Ignition Dataset with the same data and column names.</p> Source code in <code>Jandas\\__init__.py</code> <pre><code>def to_dataset(df):\n    \"\"\"\n    Convert a Jandas DataFrame to an Ignition Dataset.\n\n    Parameters:\n    - df (DataFrame): Jandas DataFrame to convert.\n\n    Returns:\n    - Dataset: Ignition Dataset with the same data and column names.\n    \"\"\"\n    if system is None:\n        raise RuntimeError(\"to_dataset requires Ignition's system module.\")\n\n    headers = df.columns\n    data = [list(row) for row in df.data]\n    return system.dataset.toDataSet(headers, data)\n</code></pre>"},{"location":"series_resampler/","title":"API Reference","text":""},{"location":"series_resampler/#Jandas.series.Resampler","title":"<code>Jandas.series.Resampler</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>class Resampler:\n    def __init__(self, series, rule):\n        self.series = series\n        self.rule = rule.upper()\n\n    def _group_by_rule(self):\n        grouped = defaultdict(list)\n\n        for idx, val in zip(self.series.index, self.series.data):\n            if self.rule == 'D':\n                key = idx.date()\n            elif self.rule == 'M':\n                key = datetime.date(idx.year, idx.month, 1)\n            elif self.rule == 'Y':\n                key = datetime.date(idx.year, 1, 1)\n            else:\n                raise ValueError(\"Unsupported resample frequency: {}\".format(self.rule))\n            grouped[key].append(val)\n\n        return grouped\n\n    def mean(self):\n        grouped = self._group_by_rule()\n        means = []\n        index = []\n\n        for key in sorted(grouped.keys()):\n            values = [v for v in grouped[key] if v is not None]\n            if values:\n                means.append(sum(values) / len(values))\n                index.append(key)\n            else:\n                means.append(None)\n                index.append(key)\n\n        return Series(means, index=index, name=self.series.name)\n\n    def sum(self):\n        grouped = self._group_by_rule()\n        totals = []\n        index = []\n\n        for key in sorted(grouped.keys()):\n            values = [v for v in grouped[key] if v is not None]\n            totals.append(sum(values) if values else 0)\n            index.append(key)\n\n        return Series(totals, index=index, name=self.series.name)\n</code></pre>"},{"location":"series_resampler/#Jandas.series.Resampler.series","title":"<code>series = series</code>  <code>instance-attribute</code>","text":""},{"location":"series_resampler/#Jandas.series.Resampler.rule","title":"<code>rule = rule.upper()</code>  <code>instance-attribute</code>","text":""},{"location":"series_resampler/#Jandas.series.Resampler.__init__","title":"<code>__init__(series, rule)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __init__(self, series, rule):\n    self.series = series\n    self.rule = rule.upper()\n</code></pre>"},{"location":"series_resampler/#Jandas.series.Resampler.mean","title":"<code>mean()</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def mean(self):\n    grouped = self._group_by_rule()\n    means = []\n    index = []\n\n    for key in sorted(grouped.keys()):\n        values = [v for v in grouped[key] if v is not None]\n        if values:\n            means.append(sum(values) / len(values))\n            index.append(key)\n        else:\n            means.append(None)\n            index.append(key)\n\n    return Series(means, index=index, name=self.series.name)\n</code></pre>"},{"location":"series_resampler/#Jandas.series.Resampler.sum","title":"<code>sum()</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def sum(self):\n    grouped = self._group_by_rule()\n    totals = []\n    index = []\n\n    for key in sorted(grouped.keys()):\n        values = [v for v in grouped[key] if v is not None]\n        totals.append(sum(values) if values else 0)\n        index.append(key)\n\n    return Series(totals, index=index, name=self.series.name)\n</code></pre>"},{"location":"series_series/","title":"API Reference","text":""},{"location":"series_series/#Jandas.series.Series","title":"<code>Jandas.series.Series</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>class Series:\n    def __init__(self, data, index=None, name=None):\n        if isinstance(data, str):\n            raise ValueError(\"Series data should be a list, not a string\")\n        if isinstance(data, Jandas.vector.Vector):\n            self.data = data.data\n        else:\n            self.data = list(data)\n        self.index = index\n        self.name = name\n\n    def __getitem__(self, key):\n        if isinstance(key, int):\n            return self.data[key]\n\n        elif isinstance(key, slice):\n            # Slice by position\n            return Series(self.data[key], name=self.name, index=self.index[key])\n\n        elif isinstance(key, str):\n            # Single label\n            try:\n                idx = self.index.index(key)\n                return self.data[idx]\n            except ValueError:\n                raise KeyError(\"Label '{}' not found in index\".format(key))\n\n        elif isinstance(key, list):\n            # List of labels or boolean mask\n            if all(isinstance(k, bool) for k in key):\n                filteredData = [d for d, mask in zip(self.data, key) if mask]\n                filteredIndex = [i for i, mask in zip(self.index, key) if mask]\n                return Series(filteredData, name=self.name, index=filteredIndex)\n\n            elif all(isinstance(k, str) for k in key):\n                indices = [self.index.index(k) for k in key]\n                filteredData = [self.data[i] for i in indices]\n                return Series(filteredData, name=self.name, index=key)\n\n            else:\n                raise TypeError(\"List indexing only supports labels or boolean masks.\")\n\n        else:\n            raise TypeError(\"Unsupported index type: {}\".format(type(key)))\n\n    def __eq__(self, other):\n        import operator\n        if isinstance(other, Series):\n            return Series(\n                [_safe_compare(a, b, operator.eq) for a, b in zip(self.data, other.data)],\n                name=\"({} == {})\".format(self.name, other.name),\n                index=self.index\n            )\n        else:\n            return Series(\n                [_safe_compare(val, other, operator.eq) for val in self.data],\n                name=\"{} == {}\".format(self.name, other),\n                index=self.index\n            )\n\n    def __gt__(self, other):\n        import operator\n        if isinstance(other, (int, float)):\n            return Series(\n                [_safe_compare(val, other, operator.gt) for val in self.data],\n                name=\"{} &gt; {}\".format(self.name, other),\n                index=self.index\n            )\n        elif isinstance(other, Series):\n            return Series(\n                [_safe_compare(a, b, operator.gt) for a, b in zip(self.data, other.data)],\n                name=\"({} &gt; {})\".format(self.name, other.name),\n                index=self.index\n            )\n        else:\n            raise TypeError(\"Unsupported operand type(s) for &gt;: '{}' and '{}'\".format(type(self), type(other)))\n\n    def __lt__(self, other):\n        import operator\n        if isinstance(other, (int, float)):\n            return Series(\n                [_safe_compare(val, other, operator.lt) for val in self.data],\n                name=\"{} &lt; {}\".format(self.name, other),\n                index=self.index\n            )\n        elif isinstance(other, Series):\n            return Series(\n                [_safe_compare(a, b, operator.lt) for a, b in zip(self.data, other.data)],\n                name=\"({} &lt; {})\".format(self.name, other.name),\n                index=self.index\n            )\n        else:\n            raise TypeError(\"Unsupported operand type(s) for &lt;: '{}' and '{}'\".format(type(self), type(other)))\n\n    def __repr__(self):\n        if self.data is None:\n            return \"Empty Series\"\n\n        if self.index is None:\n            # Fall back to range index if none was provided\n            self.index = list(range(len(self.data)))\n\n        preview = '\\n'.join(\n            \"{}    {}\".format(idx, val) for idx, val in zip(self.index, self.data)\n        )\n\n        dtype = type(self.data[0]).__name__ if self.data else \"object\"\n        return \"{}\\nName: {}, dtype: {}\".format(preview, self.name, dtype)\n\n    def __and__(self, other):\n        return Series([a and b for a, b in zip(self.data, other.data)])\n\n    def __or__(self, other):\n        return Series([a or b for a, b in zip(self.data, other.data)])\n\n    def __invert__(self):\n        return Series([not x for x in self.data])\n\n    def __len__(self):\n        return len(self.data)\n\n    def iloc(self, index):\n        return self.data[index]\n\n    @property\n    def values(self):\n        return self.data\n\n    @property\n    def kind(self):\n        # Determine the kind of data in the series by checking the type of the first element\n        if len(self.data) == 0:\n            return None  # If the series is empty, return None\n\n        # Check the type of the first element and return the kind accordingly\n        firstValue = self.data[0]\n\n        if isinstance(firstValue, (int, float)):\n            if isinstance(firstValue, float):\n                return 'float'\n            else:\n                return 'int'\n        else:\n            return 'object'\n\n    def value_counts(self):\n        \"\"\"\n        Returns a DataFrame with the counts of unique values.\n        \"\"\"\n        from .dataframe import DataFrame\n        counts = {}\n        for value in self.data:\n            counts[value] = counts.get(value, 0) + 1\n        sortedCounts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n\n        # Convert to the correct format: list of rows\n        data = [[val, count] for val, count in sortedCounts]\n\n        # Create the DataFrame with the structured data\n        return DataFrame(data=data, columns=[\"Value\", \"Count\"])\n\n    def resample(self, rule):\n        \"\"\"\n        Resample time-series data based on a frequency rule.\n\n        Parameters:\n        - rule (str): Resampling frequency ('D' = daily, 'M' = monthly, etc.)\n\n        Returns:\n        - Resampler: An object supporting aggregation like .mean()\n        \"\"\"\n        if not all(isinstance(i, datetime.datetime) for i in self.index):\n            raise TypeError(\"Resampling requires datetime.datetime index\")\n        return Resampler(self, rule)\n\n    def rolling(self, window, min_periods=None):\n        return Jandas.dataframe.Rolling(self, window, min_periods)\n\n    def map(self, func):\n        return Series([func(value) for value in self.data], self.index)\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.data","title":"<code>data = data.data</code>  <code>instance-attribute</code>","text":""},{"location":"series_series/#Jandas.series.Series.index","title":"<code>index = index</code>  <code>instance-attribute</code>","text":""},{"location":"series_series/#Jandas.series.Series.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"series_series/#Jandas.series.Series.values","title":"<code>values</code>  <code>property</code>","text":""},{"location":"series_series/#Jandas.series.Series.kind","title":"<code>kind</code>  <code>property</code>","text":""},{"location":"series_series/#Jandas.series.Series.__init__","title":"<code>__init__(data, index=None, name=None)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __init__(self, data, index=None, name=None):\n    if isinstance(data, str):\n        raise ValueError(\"Series data should be a list, not a string\")\n    if isinstance(data, Jandas.vector.Vector):\n        self.data = data.data\n    else:\n        self.data = list(data)\n    self.index = index\n    self.name = name\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __getitem__(self, key):\n    if isinstance(key, int):\n        return self.data[key]\n\n    elif isinstance(key, slice):\n        # Slice by position\n        return Series(self.data[key], name=self.name, index=self.index[key])\n\n    elif isinstance(key, str):\n        # Single label\n        try:\n            idx = self.index.index(key)\n            return self.data[idx]\n        except ValueError:\n            raise KeyError(\"Label '{}' not found in index\".format(key))\n\n    elif isinstance(key, list):\n        # List of labels or boolean mask\n        if all(isinstance(k, bool) for k in key):\n            filteredData = [d for d, mask in zip(self.data, key) if mask]\n            filteredIndex = [i for i, mask in zip(self.index, key) if mask]\n            return Series(filteredData, name=self.name, index=filteredIndex)\n\n        elif all(isinstance(k, str) for k in key):\n            indices = [self.index.index(k) for k in key]\n            filteredData = [self.data[i] for i in indices]\n            return Series(filteredData, name=self.name, index=key)\n\n        else:\n            raise TypeError(\"List indexing only supports labels or boolean masks.\")\n\n    else:\n        raise TypeError(\"Unsupported index type: {}\".format(type(key)))\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __eq__(self, other):\n    import operator\n    if isinstance(other, Series):\n        return Series(\n            [_safe_compare(a, b, operator.eq) for a, b in zip(self.data, other.data)],\n            name=\"({} == {})\".format(self.name, other.name),\n            index=self.index\n        )\n    else:\n        return Series(\n            [_safe_compare(val, other, operator.eq) for val in self.data],\n            name=\"{} == {}\".format(self.name, other),\n            index=self.index\n        )\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__gt__","title":"<code>__gt__(other)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __gt__(self, other):\n    import operator\n    if isinstance(other, (int, float)):\n        return Series(\n            [_safe_compare(val, other, operator.gt) for val in self.data],\n            name=\"{} &gt; {}\".format(self.name, other),\n            index=self.index\n        )\n    elif isinstance(other, Series):\n        return Series(\n            [_safe_compare(a, b, operator.gt) for a, b in zip(self.data, other.data)],\n            name=\"({} &gt; {})\".format(self.name, other.name),\n            index=self.index\n        )\n    else:\n        raise TypeError(\"Unsupported operand type(s) for &gt;: '{}' and '{}'\".format(type(self), type(other)))\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__lt__","title":"<code>__lt__(other)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __lt__(self, other):\n    import operator\n    if isinstance(other, (int, float)):\n        return Series(\n            [_safe_compare(val, other, operator.lt) for val in self.data],\n            name=\"{} &lt; {}\".format(self.name, other),\n            index=self.index\n        )\n    elif isinstance(other, Series):\n        return Series(\n            [_safe_compare(a, b, operator.lt) for a, b in zip(self.data, other.data)],\n            name=\"({} &lt; {})\".format(self.name, other.name),\n            index=self.index\n        )\n    else:\n        raise TypeError(\"Unsupported operand type(s) for &lt;: '{}' and '{}'\".format(type(self), type(other)))\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __repr__(self):\n    if self.data is None:\n        return \"Empty Series\"\n\n    if self.index is None:\n        # Fall back to range index if none was provided\n        self.index = list(range(len(self.data)))\n\n    preview = '\\n'.join(\n        \"{}    {}\".format(idx, val) for idx, val in zip(self.index, self.data)\n    )\n\n    dtype = type(self.data[0]).__name__ if self.data else \"object\"\n    return \"{}\\nName: {}, dtype: {}\".format(preview, self.name, dtype)\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__and__","title":"<code>__and__(other)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __and__(self, other):\n    return Series([a and b for a, b in zip(self.data, other.data)])\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__or__","title":"<code>__or__(other)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __or__(self, other):\n    return Series([a or b for a, b in zip(self.data, other.data)])\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__invert__","title":"<code>__invert__()</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __invert__(self):\n    return Series([not x for x in self.data])\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.__len__","title":"<code>__len__()</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def __len__(self):\n    return len(self.data)\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.iloc","title":"<code>iloc(index)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def iloc(self, index):\n    return self.data[index]\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.value_counts","title":"<code>value_counts()</code>","text":"<p>Returns a DataFrame with the counts of unique values.</p> Source code in <code>Jandas\\series.py</code> <pre><code>def value_counts(self):\n    \"\"\"\n    Returns a DataFrame with the counts of unique values.\n    \"\"\"\n    from .dataframe import DataFrame\n    counts = {}\n    for value in self.data:\n        counts[value] = counts.get(value, 0) + 1\n    sortedCounts = sorted(counts.items(), key=lambda x: x[1], reverse=True)\n\n    # Convert to the correct format: list of rows\n    data = [[val, count] for val, count in sortedCounts]\n\n    # Create the DataFrame with the structured data\n    return DataFrame(data=data, columns=[\"Value\", \"Count\"])\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.resample","title":"<code>resample(rule)</code>","text":"<p>Resample time-series data based on a frequency rule.</p> <p>Parameters: - rule (str): Resampling frequency ('D' = daily, 'M' = monthly, etc.)</p> <p>Returns: - Resampler: An object supporting aggregation like .mean()</p> Source code in <code>Jandas\\series.py</code> <pre><code>def resample(self, rule):\n    \"\"\"\n    Resample time-series data based on a frequency rule.\n\n    Parameters:\n    - rule (str): Resampling frequency ('D' = daily, 'M' = monthly, etc.)\n\n    Returns:\n    - Resampler: An object supporting aggregation like .mean()\n    \"\"\"\n    if not all(isinstance(i, datetime.datetime) for i in self.index):\n        raise TypeError(\"Resampling requires datetime.datetime index\")\n    return Resampler(self, rule)\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.rolling","title":"<code>rolling(window, min_periods=None)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def rolling(self, window, min_periods=None):\n    return Jandas.dataframe.Rolling(self, window, min_periods)\n</code></pre>"},{"location":"series_series/#Jandas.series.Series.map","title":"<code>map(func)</code>","text":"Source code in <code>Jandas\\series.py</code> <pre><code>def map(self, func):\n    return Series([func(value) for value in self.data], self.index)\n</code></pre>"},{"location":"vector_vector/","title":"API Reference","text":""},{"location":"vector_vector/#Jandas.vector.Vector","title":"<code>Jandas.vector.Vector</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>class Vector:\n    def __init__(self, data, columns=None, name=None):\n        \"\"\"Initialize the Vector with data.\"\"\"\n        if isinstance(data, list):\n            self.data = data\n            self.columns = columns\n            self.name = name\n        else:\n            raise TypeError(\"Data must be a list.\")\n\n    def __eq__(self, other):\n        if not isinstance(other, Vector):\n            return False\n        return self.data == other.data\n\n    def __repr__(self):\n        dtype = type(self.data[0]).__name__ if self.data else \"float\"\n        index = range(len(self.data))\n        formattedData = \"\\n\".join(\"{}    {}\".format(i, value) for i, value in zip(index, self.data))\n        return \"{}\\nName: {}, dtype: {}\".format(formattedData, self.name, dtype)\n\n    def __len__(self):\n        \"\"\"Get the length of the vector.\"\"\"\n        return len(self.data)\n\n    def __getitem__(self, index):\n        \"\"\"Indexing support.\"\"\"\n        if isinstance(index, str):  # If indexing by column name\n            if self.columns is None:\n                raise ValueError(\"Column names are not defined.\")\n            colIndex = self.columns.index(index)  # Find the column index\n            return self.data[colIndex]\n        elif isinstance(index, int):  # If indexing by position\n            return self.data[index]\n        elif isinstance(index, slice):\n            return Vector(self.data[index])\n        else:\n            raise TypeError(\"Index must be an integer or a column name.\")\n\n    def __setitem__(self, index, value):\n        \"\"\"Support for setting elements by index.\"\"\"\n        if isinstance(index, str):  # Setting value by column name\n            if self.columns is None:\n                raise ValueError(\"Column names are not defined.\")\n            colIndex = self.columns.index(index)\n            self.data[colIndex] = value\n        elif isinstance(index, int):  # Setting value by position\n            self.data[index] = value\n        else:\n            raise TypeError(\"Index must be an integer or a column name.\")\n\n    def __delitem__(self, index):\n        del self.data[index]\n\n    def _apply_operation(self, other, operation):\n        \"\"\"Helper to apply element-wise operation.\"\"\"\n        if isinstance(other, Vector):\n            if len(self) != len(other):\n                raise ValueError(\"Vectors must be the same length.\")\n            return Vector([operation(x, y) for x, y in zip(self.data, other.data)])\n        elif isinstance(other, (int, float)):\n            return Vector([operation(x, other) for x in self.data])\n        else:\n            raise TypeError(\"Unsupported operand type.\")\n\n    def __add__(self, other):\n        if isinstance(other, Vector):\n            return Vector(self.data + other.data)  # Combine two vectors\n        elif isinstance(other, list):\n            return Vector(self.data + other)  # Combine vector with list\n        else:\n            raise TypeError(\"Unsupported operand type for +: 'Vector' and '{}'\".format(type(other).__name__))\n\n    def __sub__(self, other):\n        return self._apply_operation(other, lambda x, y: x - y)\n\n    def __mul__(self, other):\n        return self._apply_operation(other, lambda x, y: x * y)\n\n    def __truediv__(self, other):\n        return self._apply_operation(other, lambda x, y: x / y)\n\n    def __floordiv__(self, other):\n        return self._apply_operation(other, lambda x, y: x // y)\n\n    def __mod__(self, other):\n        return self._apply_operation(other, lambda x, y: x % y)\n\n    def __pow__(self, other):\n        return self._apply_operation(other, lambda x, y: x ** y)\n\n    def sum(self):\n        \"\"\"Return the sum of elements in the vector.\"\"\"\n        return sum(self.data)\n\n    def mean(self):\n        \"\"\"Return the mean of elements in the vector.\"\"\"\n        return sum(self.data) / len(self.data) if self.data else float('nan')\n\n    def min(self):\n        \"\"\"Return the minimum value in the vector.\"\"\"\n        return min(self.data)\n\n    def max(self):\n        \"\"\"Return the maximum value in the vector.\"\"\"\n        return max(self.data)\n\n    def std(self):\n        \"\"\"Return the standard deviation of elements.\"\"\"\n        mean = self.mean()\n        return (sum([(x - mean) ** 2 for x in self.data]) / len(self.data)) ** 0.5\n\n    def dot(self, other):\n        \"\"\"Return the dot product with another vector.\"\"\"\n        if len(self) != len(other):\n            raise ValueError(\"Vectors must be the same length for dot product.\")\n        return sum(x * y for x, y in zip(self.data, other.data))\n\n    def transpose(self):\n        \"\"\"Return the transposed vector (just a copy in 1D).\"\"\"\n        return self  # For 1D vector, transpose is trivial.\n\n    def apply(self, func):\n        \"\"\"Apply a function element-wise.\"\"\"\n        return Vector([func(x) for x in self.data])\n\n    def __iter__(self):\n        \"\"\"Iterator for the vector.\"\"\"\n        return iter(self.data)\n\n    def as_array(self):\n        \"\"\"Return the raw list (or array in Java terms).\"\"\"\n        return self.data\n\n    def to_list(self):\n        # Simply return the data attribute as a list\n        return self.data\n\n    def map(self, func):\n        \"\"\"Apply a function to each element of the vector and return a new vector.\"\"\"\n        return Vector([func(x) for x in self.data])\n\n    def pop(self, index):\n        \"\"\"Remove and return the element at the specified index.\"\"\"\n        return self.data.pop(index)\n\n    @staticmethod\n    def from_array(arr):\n        \"\"\"Convert a raw array (list) to a Vector.\"\"\"\n        return Vector(arr)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.data","title":"<code>data = data</code>  <code>instance-attribute</code>","text":""},{"location":"vector_vector/#Jandas.vector.Vector.columns","title":"<code>columns = columns</code>  <code>instance-attribute</code>","text":""},{"location":"vector_vector/#Jandas.vector.Vector.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"vector_vector/#Jandas.vector.Vector.__init__","title":"<code>__init__(data, columns=None, name=None)</code>","text":"<p>Initialize the Vector with data.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def __init__(self, data, columns=None, name=None):\n    \"\"\"Initialize the Vector with data.\"\"\"\n    if isinstance(data, list):\n        self.data = data\n        self.columns = columns\n        self.name = name\n    else:\n        raise TypeError(\"Data must be a list.\")\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __eq__(self, other):\n    if not isinstance(other, Vector):\n        return False\n    return self.data == other.data\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __repr__(self):\n    dtype = type(self.data[0]).__name__ if self.data else \"float\"\n    index = range(len(self.data))\n    formattedData = \"\\n\".join(\"{}    {}\".format(i, value) for i, value in zip(index, self.data))\n    return \"{}\\nName: {}, dtype: {}\".format(formattedData, self.name, dtype)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__len__","title":"<code>__len__()</code>","text":"<p>Get the length of the vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def __len__(self):\n    \"\"\"Get the length of the vector.\"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Indexing support.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def __getitem__(self, index):\n    \"\"\"Indexing support.\"\"\"\n    if isinstance(index, str):  # If indexing by column name\n        if self.columns is None:\n            raise ValueError(\"Column names are not defined.\")\n        colIndex = self.columns.index(index)  # Find the column index\n        return self.data[colIndex]\n    elif isinstance(index, int):  # If indexing by position\n        return self.data[index]\n    elif isinstance(index, slice):\n        return Vector(self.data[index])\n    else:\n        raise TypeError(\"Index must be an integer or a column name.\")\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__setitem__","title":"<code>__setitem__(index, value)</code>","text":"<p>Support for setting elements by index.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def __setitem__(self, index, value):\n    \"\"\"Support for setting elements by index.\"\"\"\n    if isinstance(index, str):  # Setting value by column name\n        if self.columns is None:\n            raise ValueError(\"Column names are not defined.\")\n        colIndex = self.columns.index(index)\n        self.data[colIndex] = value\n    elif isinstance(index, int):  # Setting value by position\n        self.data[index] = value\n    else:\n        raise TypeError(\"Index must be an integer or a column name.\")\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__delitem__","title":"<code>__delitem__(index)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __delitem__(self, index):\n    del self.data[index]\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__add__","title":"<code>__add__(other)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, Vector):\n        return Vector(self.data + other.data)  # Combine two vectors\n    elif isinstance(other, list):\n        return Vector(self.data + other)  # Combine vector with list\n    else:\n        raise TypeError(\"Unsupported operand type for +: 'Vector' and '{}'\".format(type(other).__name__))\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__sub__","title":"<code>__sub__(other)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __sub__(self, other):\n    return self._apply_operation(other, lambda x, y: x - y)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__mul__","title":"<code>__mul__(other)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __mul__(self, other):\n    return self._apply_operation(other, lambda x, y: x * y)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__truediv__","title":"<code>__truediv__(other)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __truediv__(self, other):\n    return self._apply_operation(other, lambda x, y: x / y)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__floordiv__","title":"<code>__floordiv__(other)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __floordiv__(self, other):\n    return self._apply_operation(other, lambda x, y: x // y)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__mod__","title":"<code>__mod__(other)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __mod__(self, other):\n    return self._apply_operation(other, lambda x, y: x % y)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__pow__","title":"<code>__pow__(other)</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def __pow__(self, other):\n    return self._apply_operation(other, lambda x, y: x ** y)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.sum","title":"<code>sum()</code>","text":"<p>Return the sum of elements in the vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def sum(self):\n    \"\"\"Return the sum of elements in the vector.\"\"\"\n    return sum(self.data)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.mean","title":"<code>mean()</code>","text":"<p>Return the mean of elements in the vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def mean(self):\n    \"\"\"Return the mean of elements in the vector.\"\"\"\n    return sum(self.data) / len(self.data) if self.data else float('nan')\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.min","title":"<code>min()</code>","text":"<p>Return the minimum value in the vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def min(self):\n    \"\"\"Return the minimum value in the vector.\"\"\"\n    return min(self.data)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.max","title":"<code>max()</code>","text":"<p>Return the maximum value in the vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def max(self):\n    \"\"\"Return the maximum value in the vector.\"\"\"\n    return max(self.data)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.std","title":"<code>std()</code>","text":"<p>Return the standard deviation of elements.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def std(self):\n    \"\"\"Return the standard deviation of elements.\"\"\"\n    mean = self.mean()\n    return (sum([(x - mean) ** 2 for x in self.data]) / len(self.data)) ** 0.5\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.dot","title":"<code>dot(other)</code>","text":"<p>Return the dot product with another vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def dot(self, other):\n    \"\"\"Return the dot product with another vector.\"\"\"\n    if len(self) != len(other):\n        raise ValueError(\"Vectors must be the same length for dot product.\")\n    return sum(x * y for x, y in zip(self.data, other.data))\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.transpose","title":"<code>transpose()</code>","text":"<p>Return the transposed vector (just a copy in 1D).</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def transpose(self):\n    \"\"\"Return the transposed vector (just a copy in 1D).\"\"\"\n    return self  # For 1D vector, transpose is trivial.\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.apply","title":"<code>apply(func)</code>","text":"<p>Apply a function element-wise.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def apply(self, func):\n    \"\"\"Apply a function element-wise.\"\"\"\n    return Vector([func(x) for x in self.data])\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterator for the vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterator for the vector.\"\"\"\n    return iter(self.data)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.as_array","title":"<code>as_array()</code>","text":"<p>Return the raw list (or array in Java terms).</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def as_array(self):\n    \"\"\"Return the raw list (or array in Java terms).\"\"\"\n    return self.data\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.to_list","title":"<code>to_list()</code>","text":"Source code in <code>Jandas\\vector.py</code> <pre><code>def to_list(self):\n    # Simply return the data attribute as a list\n    return self.data\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.map","title":"<code>map(func)</code>","text":"<p>Apply a function to each element of the vector and return a new vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def map(self, func):\n    \"\"\"Apply a function to each element of the vector and return a new vector.\"\"\"\n    return Vector([func(x) for x in self.data])\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.pop","title":"<code>pop(index)</code>","text":"<p>Remove and return the element at the specified index.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>def pop(self, index):\n    \"\"\"Remove and return the element at the specified index.\"\"\"\n    return self.data.pop(index)\n</code></pre>"},{"location":"vector_vector/#Jandas.vector.Vector.from_array","title":"<code>from_array(arr)</code>  <code>staticmethod</code>","text":"<p>Convert a raw array (list) to a Vector.</p> Source code in <code>Jandas\\vector.py</code> <pre><code>@staticmethod\ndef from_array(arr):\n    \"\"\"Convert a raw array (list) to a Vector.\"\"\"\n    return Vector(arr)\n</code></pre>"}]}